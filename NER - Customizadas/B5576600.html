<!DOCTYPE html><html lang = "en"><head><meta charset = "utf-8"><meta name = "viewport" content = "width=device-width, initial-scale=1"><title>JDE Object Browser HTML Extract</title>
<style type='text/css'>body,th{font-family: Courier New, Courier, mono;font-size: 12px; width:auto}
.section{font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width: 100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.objectheader {font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width:auto;background-color: #FFFFCC;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.details{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px;box-sizing: border-box }
.er {background-color: #FFFFFF;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal; border: thin solid #CCCCCC; width:auto; padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.dstrmembers {background-color: #FFFDDD;font-family: Courier New, Courier, mono;font-size: 12px;border: thin groove #CC9966;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.disabled {font-family: Courier New, Courier, mono;font-size: 12px;	font-style: italic; color:#CC9933}
.parameters {font-family: Courier New, Courier, mono;font-size: 12px; color:#3333FF}
.comment {font-family: Courier New, Courier, mono;font-size: 12px;	color: #339933}
.subtable {font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;width:100%}
.lineno {color:#6E6E6E;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.iokey {color:#FF6905;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.logicline {color:#000000;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.versionoverride {background-color: #FFCC99;}
.overrideflags{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:auto;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; background-color: #FFCC99; box-sizing: border-box }
.bsfnprops {font-family: Courier New, Courier, mono;font-size: 12px; color:#E01B4C}
.searchresult {font-family: Courier New, Courier, mono;font-size: 12px; font-weight: bold; background-color:#8BF3A0}
.expand {font-family: Courier New, Courier, mono;font-size: 11px; font-weight: bold; cursor:pointer; border: 1px solid gray; position: relative; left: -3px; display:inline; line-height:8px;}
.expand2 { display:inline; cursor:pointer; font-size: 9px; border: 1px solid gray; position: relative; left: -3px;}
</style>
<script type='text/javascript'>function load(){location.href = '#result';}</script>
<script language='JavaScript' type='text/javascript'>function ExpandCollapse(ElementId){ var ClickedElement = document.getElementById(ElementId); var SectionName = ElementId + ':hide'; var Section = document.getElementById(SectionName); if (ClickedElement.innerHTML == '-') { 	 ClickedElement.innerHTML = '+';	Section.style.display = 'none'; }  else  { 		ClickedElement.innerHTML = '-'; 	Section.style.display = 'inline';}} </script>
<base target = "_parent"></head><body onload='load()'>
<div class ='objectheader'>Business Function: B5576600 - Validar CGC/CPF<BR>Function Type: C</div><div class='section'>EVENTS<div class='objectheader'>C Function: Validar CGC/CPF - [ValidarCGC]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D5576600 - Validar CGC/CPF                                             </B><BR>BF NrInscricaoFederal [TAX]<BR>BF TpInscricaoFederal [TAXC]<BR>BF CdErro [DTAI]<BR>BF szUF [ADDS]<BR>BF szPais [CTR]<BR></div><pre><div class='dstrmembers'><B>Header File: b5576600.h</B><BR></div><br/>/*****************************************************************************<br/> *    Header File:  B5576600.h<br/> *<br/> *    Description:  C.G.C. Check Digit - Brazil Header File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 03/11/1997  RG5597037   1359251  - C.G.C. Check Digit - Brazil  <br/> *<br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source <br/> * Company.  All rights reserved.  The methods and techniques described <br/> * herein are considered trade secrets and/or confidential.  Reproduction<br/> * or distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/><br/>#ifndef __B5576600_H<br/>#define __B5576600_H<br/><br/>/*****************************************************************************<br/> * Table Header Inclusions<br/> ****************************************************************************/<br/>#include &ltf0101.h&gt<br/>#include &ltf0116.h&gt<br/>/*****************************************************************************<br/> * External Business Function Header Inclusions<br/> ****************************************************************************/<br/>#include &ltb4000770.h&gt<br/><br/>/*To read definition of dsDE0022*/<br/>#include &ltb9800100.h&gt<br/>/*****************************************************************************<br/> * Global Definitions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * Structure Definitions<br/> ****************************************************************************/<br/>#ifndef __V0101BR__<br/>#define __V0101BR__<br/><br/>#define DATA_VERSION_V0101BR  1<br/>#define ID_BV0101BR  _J("V0101BR")<br/>#define STABLENAME_BV0101BR  _J("BV0101BR")<br/><br/>typedef struct<br/>{<br/>#define NID_AN8  _J("AN8")<br/>   MATH_NUMERIC   aban8;               /* 0 to 48 */<br/>#define NID_AN8  _J("AN8")<br/>   MATH_NUMERIC   alan8;               /* 49 to 97 */<br/>#define NID_EFTB  _J("EFTB")<br/>   JDEDATE        aleftb;              /* 98 to 103 */<br/>#define NID_ADDS  _J("ADDS")<br/>   JCHAR           aladds[4];           /* 104 to 107 */<br/>#define NID_TX2  _J("TX2")<br/>   JCHAR           abtx2[21];           /* 108 to 128 */<br/>} BV0101BR, FAR *LPBV0101BR;<br/><br/>#endif<br/><br/>/*****************************************************************************<br/> * DS Template Type Definitions<br/> ****************************************************************************/<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: C.G.C. Check Digit - Brazil<br/> *    Template ID:   D5576600<br/> *    Generated:     Tue Mar 11 15:51:28 1997<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the Everest Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D5576600<br/>#define DATASTRUCTURE_D5576600<br/><br/>typedef struct tagDSD5576600<br/>{<br/>  JCHAR          NrInscricaoFederal[21];<br/>  JCHAR          TpInscricaoFederal;<br/>  JCHAR          CdErro[11];<br/>  JCHAR          szUF[4];<br/>  JCHAR          szPais[4];<br/>} DSD5576600 , *LPDSD5576600;<br/><br/>#define IDERRNrInscricaoFederal_4                 4L<br/>#define IDERRTpInscricaoFederal_5                 5L<br/>#define IDERRCdErro_6                             6L<br/>#define IDERRszUF_7                               7L<br/>#define IDERRszPais_8                             8L<br/><br/>#endif /* DATASTRUCTURE_D5576600 */<br/><br/>/*<br/> * Structure Name - D7602122I<br/> *<br/> * Description - Structure for data sent to I7602122_StandardTaxIDValidation<br/> *  <br/> **************************************/<br/><br/>typedef struct <br/>{<br/>  JCHAR              szTaxId[21];<br/>  short             iWeights1[21];                      <br/>  short	            iWeights2[21];                      <br/>  int               nModulus;<br/>  int				nModulus2; <br/>  int               nNoCheckDigits;                      <br/>  JCHAR              szState[4]; <br/>  short				iWeightsLength1;<br/>  short				iWeightsLength2;<br/>  int				iAmapaD;<br/>  int				iAmapaP;<br/>  JCHAR              cErrorFlag;                  <br/>} DSD7602122I, *LPDSD7602122I;<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Brazilian State Tax ID Validation<br/> *    Template ID:   D7602122<br/> *    Generated:     Wed Aug 29 11:46:31 2001<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D7602122<br/>#define DATASTRUCTURE_D7602122<br/><br/>typedef struct tagDSD7602122<br/>{<br/>  JCHAR              szTaxId2[21];                        <br/>  JCHAR              szState[4];                          <br/>  JCHAR              szCountry[4];                        <br/>  JCHAR              cPODuplicateTaxIDAllowedYN;          <br/>  JCHAR              cPODuplicateTaxIDErrorORWarn;        <br/>  MATH_NUMERIC      mnAddressNumber;                     <br/>} DSD7602122, *LPDSD7602122;<br/><br/>#define IDERRszTaxId2_1                           1L<br/>#define IDERRszState_2                            2L<br/>#define IDERRszCountry_3                          3L<br/>#define IDERRcPODuplicateTaxIDAllowedYN_4         4L<br/>#define IDERRcPODuplicateTaxIDErrorORWarn_5       5L<br/>#define IDERRmnAddressNumber_6                    6L<br/><br/>#endif<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Address Book Additional Information - Brazil<br/> *    Template ID:   T01012BR<br/> *    Generated:     Tue Apr 10 08:09:04 2001<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_T01012BR<br/>#define DATASTRUCTURE_T01012BR<br/><br/>typedef struct tagDST01012BR<br/>{<br/>  JCHAR              cWarningorError;                     <br/>  JCHAR              cWarningOrErrorCPF;                  <br/>  JCHAR              cDuplicateCGCYesNo;                  <br/>  JCHAR              cDuplicateCPFYesNo;                  <br/>  JCHAR              cDuplicateCGCWarningError;           <br/>  JCHAR              cDuplicateCPFWarningError;           <br/>  JCHAR              cDuplicateStateYN;                   <br/>  JCHAR              cDuplicateStateWarningError;         <br/>} DST01012BR, *LPDST01012BR;<br/><br/>#define IDERRcWarningorError_1                    1L<br/>#define IDERRcWarningOrErrorCPF_2                 2L<br/>#define IDERRcDuplicateCGCYesNo_3                 3L<br/>#define IDERRcDuplicateCPFYesNo_4                 4L<br/>#define IDERRcDuplicateCGCWarningError_5          5L<br/>#define IDERRcDuplicateCPFWarningError_6          6L<br/>#define IDERRcDuplicateStateYN_7                  7L<br/>#define IDERRcDuplicateStateWarningError_8        8L<br/><br/>#endif<br/><br/>/*****************************************************************************<br/> * Source Preprocessor Definitions<br/> ****************************************************************************/<br/>#if defined (JDEBFRTN)<br/>	#undef JDEBFRTN<br/>#endif<br/><br/>#if defined (WIN32)<br/>	#if defined (WIN32)<br/>		#define JDEBFRTN(r) __declspec(dllexport) r<br/>	#else<br/>		#define JDEBFRTN(r) __declspec(dllimport) r<br/>	#endif<br/>#else<br/>	#define JDEBFRTN(r) r<br/>#endif<br/><br/>/*****************************************************************************<br/> * Business Function Prototypes<br/> ****************************************************************************/<br/>JDEBFRTN (ID) JDEBFWINAPI ValidarCGC  (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD5576600 lpDS);<br/><br/><br/>/*****************************************************************************<br/> * Internal Function Prototypes<br/> ****************************************************************************/<br/>VOID I5576600_CPFCheckDigit_Brazil (HUSER hUser, LPBHVRCOM lpBhvrCom, JCHAR *CdErro, LPDSD5576600 lpDS);<br/>ID I5576600_BrazilianStateTaxIDValidation (HUSER hUser, LPBHVRCOM lpBhvrCom, LPVOID lpVoid, JCHAR *CdErro, DSD7602122 lpDS);<br/>ID I5576600_StandardTaxIDValidation (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD7602122I lpDSData);<br/><br/>#endif    /* __B5576600_H */<br/><br/></pre><BR/><pre><div class='dstrmembers'><B>Source File: b5576600.c</B><BR></div>#include &ltjde.h&gt<br/>#include &ltstdlib.h&gt<br/><br/>#define b5576600_c<br/><br/><br/>/*****************************************************************************<br/> *    Source File:  b5576600.c<br/> *<br/> *    Description:  C.G.C. Check Digit - Brazil Source File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 03/11/1997  RG5597037   1359251 - C.G.C. Check Digit - Brazil  <br/> *          11/15/1997  DP5735559   1795319 - Added Mask to Successful Check<br/> *          07/27/1998  RO5658573   2247509 - Added PO to issue warning or error<br/> *          08/13/1998  RO5658573   2386218 - Pass Error back to calling application<br/> *	         11/15/1998	NP5885178	2618576 - Removed mask on successful check<br/> *	         01/20/1999	NP5885178	2736433 - Hard/Soft processing options<br/> *	         04/14/1999	RO5658573	3019786 - Memory violation<br/> *          08/31/1999  FL5970532   3376353 - Memory violation errors<br/> *          11/30/2001  JH5597272   5632445  - Unicode reviewed - No Changes<br/> *			08/31/2004	eh7502505	7308331 - Localization memory issues<br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source Company.<br/> * All rights reserved.  The methods and techniques described herein are<br/> * considered trade secrets and/or confidential.  Reproduction or<br/> * distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/>/**************************************************************************<br/> * Notes:<br/> *<br/> **************************************************************************/<br/><br/>#include &ltb5576600.h&gt<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  ValidarCGC<br/> *<br/> *        Description:  Validar CGC<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD5576600        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI ValidarCGC (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD5576600 lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/	<br/>	<br/>	int				iArrayP[14]={2,3,4,5,6,7,8,9,2,3,4,5,6,7};<br/>	JCHAR			cArrayW[21]={_J(' ')},cArrayG[21]={_J(' ')};<br/>	JCHAR			cArrayC[14]={_J(' ')};<br/>	JCHAR			cArrayI[13]={_J(' ')};<br/>	JCHAR			cArrayInt[2]={_J(' ')},cArrayCal[2]={_J(' ')};<br/>	int				iCount1,iCount2,iRem;<br/>	unsigned int	iTotal,iProd,iTemp,iCdigit;<br/>	div_t			fDiv;<br/>	ID				eReturn=ER_SUCCESS;<br/>	HUSER		   	hUser			   = (HUSER)  NULL ;<br/>	ID              idJDBReturn        = JDEDB_PASSED;	<br/>	<br/>   /************************************************************************<br/>   * Declare pointers<br/>   ************************************************************************/<br/>	DSD7602122    zDS2122 = { 0 };<br/><br/>   /************************************************************************<br/>   * Check for NULL pointers<br/>   ************************************************************************/<br/>   if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD5576600)	NULL))<br/>   {<br/>     jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>     return ER_ERROR;<br/>   }<br/><br/>   /************************************************************************<br/>    * Set pointers<br/>    ************************************************************************/<br/>	<br/>   /**************************************************************************<br/>    * Initialize Behavior Routine.<br/>    **************************************************************************/<br/>    idJDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *)NULL,<br/>                                                          JDEDB_COMMIT_AUTO);<br/>    if (idJDBReturn != JDEDB_PASSED)<br/>    {<br/>		jdeErrorSet(lpBhvrCom, lpVoid, (ID)0, _J("078S"), (LPVOID)NULL);<br/>        return ER_ERROR;<br/>    }<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/><br/>	if (lpDS-&gtTpInscricaoFederal == _J('1'))<br/>	{<br/>		 	I5576600_CPFCheckDigit_Brazil ( hUser, lpBhvrCom,(JCHAR *) &lpDS-&gtCdErro, lpDS);<br/>	}<br/>	else <br/>		if(lpDS-&gtTpInscricaoFederal == _J('2'))<br/>		{			<br/>		<br/>				/* Populate the Array with entered Parameter */<br/><br/>			   jdeStrncpyTerminate(cArrayW, lpDS-&gtNrInscricaoFederal,<br/>						 DIM(cArrayW));<br/><br/>			   iCount1=21;<br/>			   for (iCount2=20;iCount2&gt=0;iCount2--)<br/>			   {<br/>				   if ((cArrayW[iCount2]&gt=_J('0')) && (cArrayW[iCount2]&lt=_J('9')))<br/>				   {<br/>					   iCount1--;<br/>					   cArrayG[iCount1]=cArrayW[iCount2];<br/>				   }<br/>			   }<br/><br/>			   /* Determine the Actual Check Digit enter by User */<br/><br/>			   cArrayInt[0]=cArrayG[19];<br/>			   cArrayInt[1]=cArrayG[20];<br/><br/>			   /* Populate Work Arrays for Operations */<br/><br/>			   iCount1=13;<br/>			   for (iCount2=18;iCount2&gt=6;iCount2--)<br/>			   {<br/>				   iCount1--;<br/>				   cArrayI[iCount1]=cArrayG[iCount2];<br/>				   if ((cArrayI[iCount1]&lt_J('0')) || (cArrayI[iCount1]&gt_J('9')))<br/>					   cArrayI[iCount1]=_J(' ');<br/>			   }<br/><br/>			   for (iCount2=0;iCount2&lt=12;iCount2++)<br/>				   cArrayC[iCount2]=cArrayI[iCount2];<br/>			   cArrayC[13]=_J(' ');<br/><br/>			   /*Calculate the first Check Digit */<br/><br/>			   iCount1=0;<br/>			   iTotal=0;<br/>			   for (iCount2=12;iCount2&gt=0;iCount2--)<br/>			   {<br/>				   if (cArrayC[iCount2] == _J(' '))<br/>				   {<br/>					   iTemp=0;<br/>				   }<br/>				   else<br/>				   {<br/>					   iTemp=((int) cArrayC[iCount2])-_J('0');<br/>				   }<br/>				   iProd=iTemp*iArrayP[iCount1];<br/>				   iTotal+=iProd;<br/>				   iCount1++;<br/>			   }<br/><br/>			   fDiv=div(iTotal,11);<br/>			   iRem=(int) fDiv.rem;<br/>			   if (iRem==0)<br/>			   {<br/>				   cArrayC[13]=_J('0');<br/>				   cArrayCal[0]=_J('0');<br/>			   }<br/>			   else<br/>			   {<br/>				   iCdigit=11-iRem;<br/>				   if (iCdigit &lt 10)<br/>				   {<br/>					   cArrayC[13]=(JCHAR) (iCdigit+_J('0'));<br/>					   cArrayCal[0]=(JCHAR) (iCdigit+_J('0'));<br/>				   }<br/>				   else<br/>				   {<br/>					   cArrayC[13]=_J('0');<br/>					   cArrayCal[0]=_J('0');<br/>				   }<br/>			   }<br/><br/>			   /* Calculate the second Check Digit */<br/><br/>			   iCount1=0;<br/>			   iTotal=0;<br/>			   for (iCount2=13;iCount2&gt=0;iCount2--)<br/>			   {<br/>				   if (cArrayC[iCount2] == _J(' '))<br/>				   {<br/>					   iTemp=0;<br/>				   }<br/>				   else<br/>				   {<br/>					   iTemp=((int) cArrayC[iCount2])-_J('0');<br/>				   }<br/>				   iProd=iTemp*iArrayP[iCount1];<br/>				   iTotal+=iProd;<br/>				   iCount1++;<br/>			   }<br/><br/>			   fDiv=div(iTotal,11);<br/>			   iRem=(int) fDiv.rem;<br/>			   if (iRem==0)<br/>			   {<br/>				   cArrayCal[1]=_J('0');<br/>			   }<br/>			   else<br/>			   {<br/>				   iCdigit=11-iRem;<br/>				   if (iCdigit &lt10)<br/>				   {<br/>					   cArrayCal[1]=(JCHAR) (iCdigit+_J('0'));<br/>				   }<br/>				   else<br/>				   {<br/>					   cArrayCal[1]=_J('0');<br/>				   }<br/>			   }<br/>				<br/>			   /* Verify the Check Digit with value enter by User */<br/><br/>			   if ((cArrayInt[0] != cArrayCal[0]) || (cArrayInt[1] != cArrayCal[1]))<br/>			   {<br/>					   jdeStrncpy (lpDS-&gtCdErro, _J("099F"), DIM( lpDS-&gtCdErro));<br/>			   }<br/>		<br/>		} <br/>		else <br/>			if(lpDS-&gtTpInscricaoFederal == _J('3'))<br/>			{<br/>			<br/>					jdeStrncpyTerminate( zDS2122.szTaxId2 , lpDS-&gtNrInscricaoFederal , DIM( zDS2122.szTaxId2 ) );<br/>					jdeStrncpyTerminate( zDS2122.szState , lpDS-&gtszUF , DIM( zDS2122.szState ) );<br/>					jdeStrncpyTerminate( zDS2122.szCountry , lpDS-&gtszPais , DIM( zDS2122.szCountry ) );<br/>					zDS2122.cPODuplicateTaxIDAllowedYN = _J('1');<br/>					zDS2122.cPODuplicateTaxIDErrorORWarn = _J('1');<br/>				<br/>					I5576600_BrazilianStateTaxIDValidation ( hUser, lpBhvrCom, lpVoid, (JCHAR *) &lpDS-&gtCdErro, zDS2122);				<br/>							<br/>	<br/>			}//Fim do if Else<br/>   <br/>	/************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>     JDB_FreeBhvr(hUser); <br/><br/>     return (eReturn);<br/>}<br/><br/><br/><br/>/**************************************************************************<br/> *  Business Function:  CPFCheckDigit_Brazil<br/> *<br/> *        Description:  C. P. F. Check Digit Brazil<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDS                lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>VOID I5576600_CPFCheckDigit_Brazil (HUSER hUser, LPBHVRCOM lpBhvrCom, JCHAR *CdErro, LPDSD5576600 lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>	int				iArrayP[14]={2,3,4,5,6,7,8,9,10,2,3,4,5,6};<br/>	int				iArrayP2[15]={2,3,4,5,6,7,8,9,10,11,2,3,4,5,6};<br/>	JCHAR			cArrayW[21]={_J(' ')},cArrayG[21]={_J(' ')};<br/>	JCHAR			cArrayC[15]={_J(' ')};<br/>	JCHAR			cArrayI[13]={_J(' ')};<br/>	JCHAR			cArrayInt[2]={_J(' ')},cArrayCal[2]={_J(' ')};<br/>	int				iCount1,iCount2,iRem;<br/>	unsigned int	iTotal,iProd,iTemp,iCdigit;<br/>	div_t			fDiv;<br/><br/>   /************************************************************************<br/>    * Declare structures<br/>    ************************************************************************/<br/><br/>	LPDST01012BR		lpdsProcOptions = (LPDST01012BR) NULL;<br/>   <br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>   /* Populate the Array with enter Parameter */<br/><br/>   jdeStrncpyTerminate(cArrayW, lpDS-&gtNrInscricaoFederal,	 DIM(cArrayW));<br/><br/>   iCount1=21;<br/>   for (iCount2=20;iCount2&gt=0;iCount2--)<br/>   {<br/>	   if ((cArrayW[iCount2]&gt=_J('0')) && (cArrayW[iCount2]&lt=_J('9')))<br/>	   {<br/>		   iCount1--;<br/>		   cArrayG[iCount1]=cArrayW[iCount2];<br/>	   }<br/>   }<br/><br/>   /* Determine the Actual Check Digit enter by User */<br/><br/>   cArrayInt[0]=cArrayG[19];<br/>   cArrayInt[1]=cArrayG[20];<br/><br/>   /* Populate Work Arrays for Operations */<br/><br/>   iCount1=13;<br/>   for (iCount2=18;iCount2&gt=6;iCount2--)<br/>   {<br/>	   iCount1--;<br/>	   cArrayI[iCount1]=cArrayG[iCount2];<br/>	   if ((cArrayI[iCount1]&lt_J('0')) || (cArrayI[iCount1]&gt_J('9')))<br/>		   cArrayI[iCount1]=_J(' ');<br/>   }<br/><br/>   for (iCount2=0;iCount2&lt=12;iCount2++)<br/>	   cArrayC[iCount2]=cArrayI[iCount2];<br/>   cArrayC[13]=_J(' ');<br/>   cArrayC[14]=_J(' ');<br/><br/>   /*Calculate the first Check Digit */<br/><br/>   iCount1=0;<br/>   iTotal=0;<br/>   for (iCount2=12;iCount2&gt=0;iCount2--)<br/>   {<br/>	   if (cArrayC[iCount2] == _J(' '))<br/>	   {<br/>		   iTemp=0;<br/>	   }<br/>	   else<br/>	   {<br/>		   iTemp=((int) cArrayC[iCount2])-_J('0');<br/>	   }<br/>	   iProd=iTemp*iArrayP[iCount1];<br/>	   iTotal+=iProd;<br/>	   iCount1++;<br/>   }<br/><br/>   fDiv=div(iTotal,11);<br/>   iRem=(int) fDiv.rem;<br/>   if (iRem==0)<br/>   {<br/>	   cArrayC[13]=_J('0');<br/>	   cArrayCal[0]=_J('0');<br/>   }<br/>   else<br/>   {<br/>	   iCdigit=11-iRem;<br/>	   if (iCdigit &lt 10)<br/>	   {<br/>		   cArrayC[13]=(JCHAR) (iCdigit+_J('0'));<br/>		   cArrayCal[0]=(JCHAR) (iCdigit+_J('0'));<br/>	   }<br/>	   else<br/>	   {<br/>		   cArrayC[13]=_J('0');<br/>		   cArrayCal[0]=_J('0');<br/>	   }<br/>   }<br/><br/>  /*Calculate the second Check Digit */<br/><br/>   iCount1=0;<br/>   iTotal=0;<br/>   for (iCount2=13;iCount2&gt=0;iCount2--)<br/>   {<br/>	   if (cArrayC[iCount2] == _J(' '))<br/>	   {<br/>		   iTemp=0;<br/>	   }<br/>	   else<br/>	   {<br/>		   iTemp=((int) cArrayC[iCount2])-_J('0');<br/>	   }<br/>	   iProd=iTemp*iArrayP2[iCount1];<br/>	   iTotal+=iProd;<br/>	   iCount1++;<br/>   }<br/><br/>   fDiv=div(iTotal,11);<br/>   iRem=(int) fDiv.rem;<br/>   if (iRem==0)<br/>   {<br/>	   cArrayC[14]=_J('0');<br/>	   cArrayCal[1]=_J('0');<br/>   }<br/>   else<br/>   {<br/>	   iCdigit=11-iRem;<br/>	   if (iCdigit &lt 10)<br/>	   {<br/>		   cArrayC[14]=(JCHAR) (iCdigit+_J('0'));<br/>		   cArrayCal[1]=(JCHAR) (iCdigit+_J('0'));<br/>	   }<br/>	   else<br/>	   {<br/>		   cArrayC[14]=_J('0');<br/>		   cArrayCal[1]=_J('0');<br/>	   }<br/>   }<br/><br/>   /* Verify the Check Digit with value enter by User */<br/><br/>   if ((cArrayInt[0] != cArrayCal[0]) || (cArrayInt[1] != cArrayCal[1]))<br/>   {<br/>      if(!IsStringBlank(lpBhvrCom-&gtlpObj-&gtlpGlobalApp-&gtszVersion))<br/>      {<br/>         lpdsProcOptions = (LPDST01012BR)AllocatePOVersionData(hUser,<br/>			      				_J("P01012BR"),<br/>					   			lpBhvrCom-&gtlpObj-&gtlpGlobalApp-&gtszVersion,<br/>                           sizeof(DST01012BR));<br/>      }<br/>      else<br/>      {<br/>         /* If no version name passed use "ZJDE0001" */<br/>		  /* FP */<br/>         lpdsProcOptions = (LPDST01012BR)AllocatePOVersionData(hUser,<br/>                           _J("P01012BR"),<br/>								   _J("ZJDE0001"),<br/>                           sizeof(DST01012BR));<br/>      }<br/><br/>	  /* Begin SAR 7308331 */<br/>	  if (lpdsProcOptions != NULL)<br/>	  {<br/>	/* End SAR 7308331 */<br/>	   if (lpdsProcOptions-&gtcWarningOrErrorCPF == _J('1'))<br/>	   {	    <br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("099I")),	 DIM(_J("099I")));<br/>	   }<br/>	   else<br/>	   {<br/>			jdeStrncpyTerminate( CdErro, (const JCHAR *) (_J("099G")),	 DIM(_J("099G")));<br/>	   }<br/>		<br/>	   /* Begin SAR 7308331 */<br/>	   FreePODataStructure (lpdsProcOptions);<br/>	  }<br/>	  /* End SAR 7308331 */<br/>   }<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   /* Begin SAR 7308331 */<br/>   //JDB_FreeBhvr(hUser); <br/>   /* End SAR 7308331 */	<br/>}<br/><br/>ID I5576600_BrazilianStateTaxIDValidation (HUSER hUser, LPBHVRCOM lpBhvrCom, LPVOID lpVoid, JCHAR *CdErro, DSD7602122 lpDS) <br/>{<br/>	/************************************************************************<br/>	*  Variable declarations<br/>    ************************************************************************/<br/>	BOOL			bError					= (BOOL)FALSE;<br/>	ID				idReturnValue			=ER_SUCCESS;<br/>	div_t			fDivide; <br/>	MATH_NUMERIC	mnOutputNumeric;<br/>	MATH_NUMERIC	mnSubstring;	<br/>	HREQUEST		hRequestV0101BR			= (HREQUEST)NULL;<br/>	ID				idJDBReturn				= JDEDB_PASSED;<br/>    ID              idKeyExist              = JDEDB_PASSED;<br/>    SELECTSTRUCT    Select[21]              = {_J('\0')};<br/>	JCHAR			szTaxID[21]				= { _J('\0')};<br/>	JCHAR			szTaxIDStrip[21]		= {_J('\0')};<br/>	JCHAR			szConcat[4]				= {_J('\0')};<br/>	JCHAR			szConcatTaxID[14]		= {_J('\0')};<br/>	JCHAR			szConcatTaxID2[11]		= {_J('\0')};<br/>	JCHAR			szWorkStr[2]			= {_J('\0')};<br/>	JCHAR			szControlLet[10]		= {_J('\0')};<br/>	JCHAR			*ptr					= NULL;<br/>	JCHAR			szCtry2ndDesc[31]		={_J('\0')}; <br/>	JCHAR			szSubstring[9]			= {_J('\0')};<br/>	int				iTaxIDSubstr			= 0;<br/>	int				iStartPos				= 0; <br/>	int				iNumberChar				= 0;<br/>	int				iTaxID					= 0;<br/>	int				iP						= 0;<br/>	int				iD						= 0;<br/>	int				iCount					= 0;<br/>	int				iAdd					= 0;<br/>	int				iCnt					= 0;<br/>	int				iWgtCnt					= 0;<br/>	int				iRemndr					= 0;<br/>	int				iCkDig2					= 0;<br/>	int				iCkDig1					= 0; <br/>	int				iTotal					= 0; <br/>	int				iCount1					= 0;<br/>	int				iCount2					= 0;<br/>	int				iInteger				= 0;<br/>	short			iStandardWeights[8]		= {9,8,7,6,5,4,3,2};<br/>	short			iWgtsBahia1[6]			= {7,6,5,4,3,2};<br/>	short			iWgtsBahia2[7]			= {8,7,6,5,4,3,2};<br/>	short			iWgtsBahia3[8]			= {9,8,7,6,5,4,3,2};<br/>	short			iWgtsSaoInd[8]			= {1,3,4,5,6,7,8,10};<br/>	short			iWgtsSaoInd2[11]		= {3,2,10,9,8,7,6,5,4,3,2};<br/>	short			iWgtsSaoAgr[8]			= {1,3,4,5,6,7,8,10};<br/>	short			iWgtMinas2[12]			= {3,2,11,10,9,8,7,6,5,4,3,2}; <br/>	short			iWgtMinas[12]			= {1,2,1,2,1,2,1,2,1,2,1,2};<br/>	short			iWgtRondonia[13]		= {6,5,4,3,2,9,8,7,6,5,4,3,2}; <br/>	short			iWgtRioDeJ[7]			= {2,7,6,5,4,3,2};<br/>	short			iWgtParana[6]			= {7,6,5,4,3,2};<br/>	short			iWgtPernam[13]			= {5,4,3,2,1,9,8,7,6,5,4,3,2};<br/>	/* Begin Modification SAR 8819862 */<br/>	short			iWgtPernam2[7]			= {8,7,6,5,4,3,2};<br/>	short			iWgtPernam3[8]			= {9,8,7,6,5,4,3,2};<br/>	/* End Modification SAR 8819862 */<br/>	short			iWgtRoraima[9]			= {1,2,3,4,5,6,7,8};<br/>	short			iWgtTocantins[10]		= {9,8,0,0,7,6,5,4,3,2};<br/>	short           iWgtTocantins2[8]       = {9,8,7,6,5,4,3,2};<br/>	/*BEGIN SAR 8040779*/<br/>	short			iWgtMatoGrosso[10]		= {3,2,9,8,7,6,5,4,3,2};<br/>	/*END SAR 8040779*/<br/>	JDEDATE         jdToday;<br/>	JDEDATE         jdTocNewIDBaseDateFormat;<br/>	int             iDateDifference         = 0;<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>    * Declare structures<br/>    ************************************************************************/<br/>	DSD4000481  dsConvertStringToNumeric;<br/>	DSD7602122I lpDSData;<br/>	DSD0005     dsD0005;<br/>	DSDE0022	dsDE0022;<br/>	BV0101BR	dsV0101BR;<br/>	<br/>	/************************************************************************<br/>    * Declare pointers<br/>    ************************************************************************/<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>	<br/>	<br/>	/************************************************************************<br/>    * Set pointers<br/>    ************************************************************************/<br/>	memset ((void *)(&lpDSData), (int)(_J('\0')), (sizeof (DSD7602122I)));<br/>	memset((void *)(&dsD0005), (int)(_J('\0')), sizeof(DSD0005));<br/>	memset((void *)(&dsDE0022),(int)(_J('\0')), sizeof(dsDE0022));	<br/>	memset((void *)(&dsV0101BR),(int)(_J('\0')), sizeof(BV0101BR));<br/>	<br/>	/************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	<br/>	/*initialize math numeric variables*/<br/>	ZeroMathNumeric(&mnSubstring);<br/>	ZeroMathNumeric(&mnOutputNumeric);<br/><br/>	/*Retrieve today's date*/<br/>	JDEDATEToday(&jdToday);<br/>	<br/>	/*Retrieve the second description of the country of the address book record.<br/>	This is done in case a blank country code is set to default as Brazil.  If<br/>	Brazil is set as the default country (or blank UDC value) - the second <br/>	description should be BR*/<br/>	jdeStrncpy(dsD0005.szSystemCode, _J("00"), DIM(dsD0005.szSystemCode) );<br/>	jdeStrncpy(dsD0005.szRecordTypeCode,_J("CN"), DIM (dsD0005.szRecordTypeCode) );<br/>	jdeStrncpy(dsD0005.szUserDefinedCode, _J(" "), DIM(dsD0005.szUserDefinedCode) );<br/>	jdeGetUserLanguagePreference(&dsD0005.szLanguagePreference);<br/>	<br/>	jdeCallObject(_J("GetUDC"), NULL, lpBhvrCom,lpVoid, (LPVOID)&dsD0005,<br/>		(LPCALLMAP)NULL, (int)0, (JCHAR *)NULL, (JCHAR *)NULL,(int)0);<br/>	<br/>	jdeStrncpy(szCtry2ndDesc, dsD0005.szDescription002, DIM(szCtry2ndDesc) );<br/>	jdeStripTrailingBlanks(szCtry2ndDesc);<br/>	<br/>	/*There are several UDC State codes in Brazil that correspond with the UDC<br/>	codes for states in the Unites States ex: Alabama = AL and Alagoas = AL.<br/>	Therefore this code can only be run if the country entered is Brazil*/ <br/>	<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szCountry),(JCHAR *)(_J("BR")),DIM(lpDS.szCountry)) == 0 )||<br/>		((jdeStrncmp((JCHAR *)(lpDS.szCountry),(JCHAR *)(_J(" ")),DIM(lpDS.szCountry)) == 0 )<br/>		&&(jdeStrncmp((JCHAR *)(szCtry2ndDesc),(JCHAR *)(_J("BR")),DIM(szCtry2ndDesc)) == 0 )))<br/>	{<br/><br/>		<br/>		/*Copy the State Tax ID into a string to be used throughout the function*/<br/>		jdeStrncpy(szTaxIDStrip,(const JCHAR *) (lpDS.szTaxId2), DIM(szTaxIDStrip));<br/>		<br/>		/*Sao Paolo Agricultural producers is the only state that has something<br/>		other than a number in its tax ID.  Therefore the P will be allowed in the <br/>		first character of the Tax ID for this state.  All other characters besides<br/>		numbers will be stripped from all state Tax IDs*/<br/>		if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("SP")),<br/>			DIM(lpDS.szState)) == 0   ) && (szTaxIDStrip[0] == _J('P')))<br/>		{<br/>			iCount1=1;<br/>			iCount2=1;<br/>			szTaxID[0] = _J('P');<br/>			<br/>		}<br/>		else<br/>		{	<br/>			iCount1=0;<br/>			iCount2=0;<br/>		}<br/>		<br/>		<br/>		/* Strip all special characters and letters*/ <br/>		/* Begin SAR 8332413 */<br/>		/*for (iCount2;iCount2&lt=20;iCount2++)*/<br/>		for ( ;iCount2&lt=20;iCount2++)<br/>		/* End SAR 8332413 */<br/>		{	<br/>			if ((szTaxIDStrip[iCount2]&gt=_J('0')) && (szTaxIDStrip[iCount2]&lt=_J('9')))<br/>			{<br/>				szTaxID[iCount1]=szTaxIDStrip[iCount2];<br/>				iCount1++;<br/>			}<br/>		}<br/>		<br/>		/* Delete all the blanks at the right */ /*find the rest of this code */<br/>		jdeStripTrailingBlanks(szTaxID);<br/>		<br/>		/*copy the clean Tax ID (without special characters or letters back onto the screen*/ <br/>		/** It is required that we insert the whole string (Special characters and letters) <br/>		    into the database so this piece of code is no longer needed. BA5905095 05/09/01 **/<br/>		  /*strncpy ((char *) lpDS-&gtszTaxId2, (const char *)(szTaxID), <br/>	  		  sizeof(lpDS-&gtszTaxId2));*/<br/>	<br/>		<br/>	/*if the Duplicate Tax ID Numbers Processing option is blank then duplicate State Tax ID's are<br/>	not allowed within each individual state.  Therefore run the check for a duplicate Tax ID.  A business<br/>	view is used to do this because Additional tax ID (TX2) is in the F0101 and the state is in the F0116<br/>		table*/<br/>		if( ((lpDS.cPODuplicateTaxIDAllowedYN  == _J(' ')) || (lpDS.cPODuplicateTaxIDAllowedYN  == _J('\0')))<br/>			&& ( jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("	")), DIM(lpDS.szState)) != 0 && <br/>			lpDS.szState[0]!=_J('\0')))<br/>		{<br/>			idJDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL, <br/>				JDEDB_COMMIT_AUTO);<br/>			<br/>			if (idJDBReturn != JDEDB_PASSED)<br/>			{<br/>				jdeSetGBRError (lpBhvrCom,lpVoid,(ID) 0,_J("078S"));<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("078S")),	 DIM(_J("078S")));<br/>				return (ER_ERROR);<br/>			}<br/>			<br/>			/* Open Address Book Business View*/<br/>			idJDBReturn = JDB_OpenView(hUser, <br/>				ID_BV0101BR,<br/>				(JCHAR *) NULL, <br/>				&hRequestV0101BR);<br/><br/>			<br/>			if (idJDBReturn == JDEDB_PASSED)<br/>			{<br/>				/* Set Data Selection*/<br/>                jdeNIDcpy(Select[0].Item1.szDict, _J("AN8"));<br/>				jdeNIDcpy(Select[0].Item1.szTable, NID_F0101);<br/>				Select[0].Item1.idInstance = (ID) 0;<br/>				Select[0].nCmp = JDEDB_CMP_NE;<br/>				Select[0].lpValue = &lpDS.mnAddressNumber;<br/>				Select[0].nValues = 1;<br/>				<br/>				Select[0].nAndOr = JDEDB_ANDOR_AND;<br/><br/>				jdeNIDcpy(Select[1].Item1.szDict, _J("TX2"));<br/>				jdeNIDcpy(Select[1].Item1.szTable, NID_F0101);<br/>				Select[1].Item1.idInstance = (ID) 0;<br/>				Select[1].nCmp = JDEDB_CMP_EQ;<br/>				Select[1].lpValue = lpDS.szTaxId2;<br/>				Select[01].nValues = 1;<br/>				<br/>				Select[1].nAndOr = JDEDB_ANDOR_AND;<br/>				<br/>				jdeNIDcpy(Select[2].Item1.szDict, _J("ADDS"));<br/>				jdeNIDcpy(Select[2].Item1.szTable, NID_F0116);<br/>				Select[2].Item1.idInstance = (ID) 0;<br/>				Select[2].nCmp = JDEDB_CMP_EQ;<br/>				Select[2].lpValue = lpDS.szState;<br/>				Select[2].nValues = 1;<br/>				<br/>				<br/>				idKeyExist = JDB_SetSelection(hRequestV0101BR,<br/>					(LPSELECT) Select,<br/>					(ushort) 3,<br/>					JDEDB_SET_REPLACE);<br/>				<br/>				<br/>				if (idKeyExist != JDEDB_PASSED) <br/>				{<br/>					memset((void *) (&dsDE0022), (int) (_J('\0')), sizeof(dsDE0022));<br/>					jdeStrncpy(dsDE0022.szDescription, (const JCHAR *) (_J("V0101BR")), DIM(dsDE0022.szDescription));<br/>					//jdeSetGBRErrorSubText(lpBhvrCom, lpVoid, (ID) 0, _J("078D"), &dsDE0022);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("078D")),	 DIM(_J("078D")));<br/>					JDB_FreeBhvr(hUser);<br/>					return (ER_ERROR);<br/>					<br/>				}<br/>				<br/>				<br/>				idKeyExist = JDB_SelectKeyed(hRequestV0101BR,<br/>					(ID) 0,<br/>					(VOID *) NULL,<br/>					(short) 0);<br/>				<br/>				if (idKeyExist != JDEDB_PASSED) <br/>				{<br/>					memset((void *) (&dsDE0022), (int) (_J('\0')), sizeof(dsDE0022));<br/>					jdeStrncpy(dsDE0022.szDescription, (const JCHAR *) (_J("V0101BR")), DIM(dsDE0022.szDescription));<br/>					//jdeSetGBRErrorSubText(lpBhvrCom, lpVoid, (ID) 0, _J("078D"), &dsDE0022);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("078D")),	 DIM(_J("078D")));<br/>					JDB_FreeBhvr(hUser);<br/>					return (ER_ERROR);<br/>					<br/>				}<br/>				<br/>				<br/>				idJDBReturn=JDB_Fetch(hRequestV0101BR, (void *) &dsV0101BR, (int)0); <br/>				<br/>				if (idJDBReturn == JDEDB_PASSED)<br/>				{<br/>				/*If the Duplicate Tax ID Error or Warning PO option is set to a 1<br/>					then set a warning*/<br/>					if(lpDS.cPODuplicateTaxIDErrorORWarn  == _J('1')) <br/>					{<br/>						<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, 	(ID) IDERRszTaxId2_1  , _J("400B"), (LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400B")),	 DIM(_J("400B")));<br/>						idReturnValue= ER_ERROR;<br/>						<br/>					}<br/>					else <br/>					{<br/>					/*If the Duplicate Tax ID Error or Warning PO option is set to a blank<br/>						then set an error*/<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400A"), (LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400A")),	 DIM(_J("400A")));<br/>						idReturnValue= ER_ERROR;<br/>						<br/>						<br/>					}<br/>					<br/>				}<br/>				<br/>			}<br/>			<br/>			<br/>	}<br/>	<br/><br/>	/************************************************************************<br/>	* Alagoas  (AL)<br/>	************************************************************************/<br/>	<br/>	/*if the State passed in is AL*/	<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("AL")),<br/>		DIM(lpDS.szState)) == 0   ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>			/* The first two characters of the Tax ID have to be 24*/<br/>			if((szTaxID[0]==_J('2')) && (szTaxID[1]==_J('4')))<br/>			{<br/>			/*Load a variable with values 0,1,3,5,6,7,8 to see if the third character<br/>				of the Tax ID is one of these values*/<br/><br/>				/* Begin SAR 7757751 */<br/>				/* Accept new values '4' and '9' in the third character for the Tax ID*/<br/><br/>				/* jdeStrncpy ((JCHAR *)szControlLet, (const JCHAR *)(_J("0135678")), <br/>					DIM(szControlLet));*/<br/>				/* Begin SAR 8927591 -To remove the validation done for 3rd character*/<br/><br/>				/* jdeStrcpy ((JCHAR *)szControlLet, (const JCHAR *)(_J("013456789")));*/<br/>				<br/>				/* End SAR 7757751 */<br/>				<br/>					/*If the third character is not one of the values 0,1,3,5,6,7, or 8<br/>				ptr will be a null pointer otherwise ptr will have a value*/<br/>				/*ptr = jdeStrchr(szControlLet, szTaxID[2]);*/<br/>				<br/>				/*If the third character is 0,1,3,5,6,7, or 8 run validation routine*/<br/>				/*if (ptr != (JCHAR*) NULL) <br/>				{END SAR 8927591*/<br/>				/*Load the  Data Structure with the appropriate values and<br/>					call the internal standard tax ID function  */ <br/>					<br/>					jdeStrncpy ((JCHAR *) lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>						DIM(lpDSData.szTaxId));<br/>					<br/>					jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>						DIM(lpDSData.szState));<br/>					<br/>					/*Load Weights*/<br/>					memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>					<br/>					/*Load Weights Length*/ <br/>					lpDSData.iWeightsLength1 = 7;<br/>					<br/>					/*Use Modulus Operator 11*/<br/>					lpDSData.nModulus = 11;<br/>					<br/>					/*Number of Check digits to be calculated*/<br/>					lpDSData.nNoCheckDigits = 1;	<br/>					<br/>					<br/>					/*Call the internal Function */<br/>					I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>					<br/>					<br/>					/* If the internal function has an error it will set an error flag<br/>					if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>					if( lpDSData.cErrorFlag == 1)<br/>					{<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>						idReturnValue= ER_ERROR;<br/>					}<br/>					<br/>				/*}<br/>				else<br/>				{<br/>				BEGIN SAR 8927591 Remove validations done for 3rd character*/<br/>					/*If the third character is not 0,1,3,5,6,7, or 8 set an error*/<br/>				/*	bError = (BOOL) TRUE;<br/>					jdeErrorSet (lpBhvrCom, lpVoid, <br/>						(ID) IDERRszTaxId2_1  , <br/>						_J("400C"), <br/>						(LPVOID) NULL);<br/>					idReturnValue= ER_ERROR;<br/>				}END SAR 8927591*/<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If the first 2 characters are not 24 set an error*/<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set and error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>		<br/>	}<br/>	<br/>	/************************************************************************<br/>	* Goias  (GO)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is GO*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("GO")), DIM(lpDS.szState)) == 0 ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{		<br/>			/* The first two characters of the Tax ID have to be 10, 11, or 15*/<br/>			if ((szTaxID[0]==_J('1')) && (szTaxID[1]==_J('0')) ||<br/>				(szTaxID[0]==_J('1')) && (szTaxID[1]==_J('1')) ||<br/>				(szTaxID[0]==_J('1')) && (szTaxID[1]==_J('5')))<br/>			{<br/>				<br/>			/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function */ <br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>					DIM(lpDSData.szState));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*Number of Check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>				if(lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), 	(LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*The first 2 digits are not 10,11, or 15 set an error*/<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), 	(LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>	}<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Maranhao  (MA)<br/>	************************************************************************/<br/>	/*If the State passed in is MA*/	<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("MA")),	DIM(lpDS.szState)) == 0   ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>			/* The first two characters of the Tax ID have to be 12*/<br/>			if((szTaxID[0]==_J('1')) && (szTaxID[1]==_J('2')))<br/>			{<br/>			/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function */ <br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*Number of Check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If the first 2 digits are not 12 set an error*/<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Mato Grosso do Sul  (MS)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is MS*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("MS")),DIM(lpDS.szState)) == 0 ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{		<br/>			/* The first two characters of the Tax ID have to be 28*/<br/>			if((szTaxID[0]==_J('2')) && (szTaxID[1]==_J('8')))<br/>			{<br/>			/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function  */ <br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*Number of Check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ 			<br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If the first 2 digits are not 28 set an error*/<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*If the Tax ID is not 9 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), 		(LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Para  (PA)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is PA*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("PA")), DIM(lpDS.szState)) == 0 ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>			/* The first two characters of the Tax ID have to be 15*/<br/>			if((szTaxID[0]==_J('1')) && (szTaxID[1]==_J('5')))<br/>			{<br/>			/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function  */ <br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*Number of Check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*if first 2 digits are not 15 set an error*/<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set an error */<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Roraima  (RR)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is RR*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("RR")),DIM(lpDS.szState)) == 0))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>			/* The first two characters of the Tax ID have to be 24*/<br/>			if((szTaxID[0]==_J('2')) && (szTaxID[1]==_J('4')))<br/>			{<br/>			/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/ <br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>					DIM(lpDSData.szState));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iWgtRoraima, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus operator 11*/<br/>				lpDSData.nModulus = 9;<br/>				<br/>				/*Number of Check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ 			<br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError =    (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If the first 2 digits are not 24 set an error*/<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set and error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Rondonia  (RO)<br/>	************************************************************************/<br/>	<br/>	<br/>	/*If the State passed in is RO*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("RO")),DIM(lpDS.szState)) == 0))<br/>	{<br/>	/*if the Tax ID length is 14 i.e. 13 digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==14)<br/>		{<br/>		/*Load the  Data Structure with the appropriate values and<br/>			call the internal standard tax ID function*/ <br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>				DIM(lpDSData.szState));<br/>			<br/>			/*Load Weights*/<br/>			memcpy(lpDSData.iWeights1, iWgtRondonia, sizeof(lpDSData.iWeights1));<br/>			<br/>			/*Load Weights Length*/ <br/>			lpDSData.iWeightsLength1 = 12;<br/>			<br/>			/*Use Modulus operator 11*/<br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The number of Check Digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 1;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/* If the internal function has an error it will set an error flag<br/>			if the error flag is equal to 1 then set a hard error on Tax ID*/ 					<br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Amapa  (AP)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is AP*/<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("AP")),	DIM(lpDS.szState)) == 0 ))<br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits assigned by the state plus 1 check <br/>		digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>			/* The first two characters of the Tax ID have to be 03*/<br/>			if((szTaxID[0]==_J('0')) && (szTaxID[1]==_J('3')))<br/>			{<br/>				/* Get a substring of characters 3 through 8 of the Tax ID*/<br/>				iStartPos   = (int)jdeAtol( _J("2") );<br/>				iNumberChar = (int)jdeAtol( _J("6") );<br/>				iStartPos   = iStartPos &gt0 ? iStartPos : 0;<br/>				iNumberChar = iNumberChar&gt0 ?iNumberChar : 0;<br/>		 /* UFC iNumberChar = iNumberChar&ltsizeof(szSubstring) ? iNumberChar: sizeof(szSubstring)-1; */<br/>				iNumberChar = iNumberChar&lt DIM(szSubstring) ? iNumberChar: DIM(szSubstring)-1;<br/>				memset( szSubstring , 0 , sizeof( szSubstring) );<br/>				jdeStrncpyTerminate(szSubstring, &szTaxID[iStartPos], iNumberChar+1);<br/>				<br/>				/*Call the Convert String to Numeric to convert these three characters<br/>				into a numeric value in order to evaluate its value in terms of this range*/<br/>				jdeStrncpy((JCHAR *)dsConvertStringToNumeric.szGenericString, (const JCHAR *)szSubstring, <br/>					DIM(dsConvertStringToNumeric.szGenericString));<br/>				<br/>				/* Convert the substring to a numeric value */<br/>				jdeCallObject(_J("ConvertStringToNumeric"),<br/>					NULL,<br/>					lpBhvrCom, lpVoid, <br/>					(LPVOID)&dsConvertStringToNumeric,<br/>					(CALLMAP*)NULL, (int)0, (JCHAR*)NULL,<br/>					(JCHAR*)NULL, (int)0);<br/>				<br/>				MathCopy (&mnOutputNumeric,&dsConvertStringToNumeric.mnNumericValue);<br/>				<br/>				MathNumericToInt (&mnOutputNumeric, &iTaxID);<br/>				<br/>				/* Variavle P and variable D are used in the tax ID validation.<br/>				Once the substring is converted to a numeric value check to see which range <br/>				it is in.  If it is greater than or equal to 1 and less than or equal to 17000<br/>				then variable P is equal to 5 and variable D is equal to 0*/ <br/>				if ( (iTaxID &gt= 1)  && (iTaxID &lt= 17000))<br/>				{<br/>					iP	  =    5;<br/>					iD    =    0;<br/>				}<br/>				/* If it is greater than or equal to 17001 and less than or equal to 19022<br/>				then variable P is equal to 9 and variable D is equal to 1*/ <br/>				else if ( (iTaxID &gt= 17001)  && (iTaxID &lt= 19022))<br/>				{<br/>					<br/>					iP   =     9;	<br/>					iD	 =     1;<br/>				}<br/>				/* Otherwise if it is greater than 19022 then variable P is equal to 0 and<br/>				variable D is equal to 0*/<br/>				else<br/>				{<br/>					iP   =     0;<br/>					iD	 =     0;<br/>				}<br/>				<br/>				<br/>				<br/>				/*Load the  Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/ <br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>					DIM(lpDSData.szState));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				<br/>				/* Pass in the value of D - if the check digit is equal to 11<br/>				the check digit will then be set to the value of D and P is added<br/>				to the product sum total before the check digit is calculated*/<br/>				lpDSData.iAmapaP = iP;<br/>				lpDSData.iAmapaD = iD;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*The number of check digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ 	<br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If the first 2 digits are not 03 set an error*/<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>	}<br/>	else<br/>	{<br/>		/*if the Tax ID is not 9 characters long set an error */<br/>		bError = (BOOL) TRUE;<br/>		//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>		jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>		idReturnValue= ER_ERROR;<br/>	}<br/>	<br/>	<br/> }<br/> <br/> <br/> /************************************************************************<br/> * Acre  (AC)<br/> ************************************************************************/<br/> <br/> <br/> /*If the State passed in is AC*/ <br/> if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("AC")), DIM(lpDS.szState)) == 0))<br/> {<br/>	/*if the Tax ID length is 13 i.e. eleven digits assigned by the state plus 2 check <br/>	 digits then proceed with validation*/<br/>	 if (jdeStrlen(szTaxID)==13)<br/>	 {<br/>		 /* The first two characters of the Tax ID have to be 01*/<br/>		 if((szTaxID[0]==_J('0')) && (szTaxID[1]==_J('1')))<br/>		 {<br/>			 <br/>		 /*Load the  Data Structure with the appropriate values and<br/>			 call the internal standard tax ID function*/ <br/>			 <br/>			 jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				 DIM(lpDSData.szTaxId));<br/>			 <br/>			 /*Load Weights*/<br/>			 memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>			 memcpy(lpDSData.iWeights2, iStandardWeights, sizeof(lpDSData.iWeights2));<br/>			 <br/>			 /*Load Weights Length*/ <br/>			 lpDSData.iWeightsLength1 = 7;<br/>			 lpDSData.iWeightsLength2 = 7;<br/>			 <br/>			 /*Use Modulus Operator 11*/<br/>			 lpDSData.nModulus = 11;<br/>			 <br/>			 /*The Number of Check Digits to be calculated*/<br/>			 lpDSData.nNoCheckDigits = 2;	<br/>			 <br/>			 /*Call the internal Function */<br/>			 I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			 <br/>			 /* If the internal function has an error it will set an error flag<br/>			 if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>			 if( lpDSData.cErrorFlag == 1)<br/>			 {<br/>				 bError =    (BOOL) TRUE;<br/>				 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				 idReturnValue= ER_ERROR;<br/>			 }<br/>			 <br/>		 }<br/>		 else<br/>		 {<br/>			 /*If the first 2 digits are not 01 set an error*/<br/>			 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>			 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			 idReturnValue= ER_ERROR;<br/>			 <br/>		 }<br/>		 <br/>	 }<br/>	 else<br/>	 {<br/>		 /*if the Tax ID is not 13 characters long */<br/>		 bError = (BOOL) TRUE;<br/>		 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>		 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>		 idReturnValue= ER_ERROR;<br/>	 }<br/>	 <br/> }<br/> <br/> <br/> <br/> /************************************************************************<br/> * Bahia  (BA)<br/> ************************************************************************/<br/> <br/> /*If the State passed in is BA*/ 	<br/> if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("BA")),<br/>	 DIM(lpDS.szState)) == 0   ))<br/> {<br/> /*if the Tax ID length is 8 i.e. six digits assigned by the state plus 2 check <br/>     digits then proceed with validation*/<br/>	 if (jdeStrlen(szTaxID)==8)<br/>	 {	<br/>	 /*The second check digit is calculated first and then<br/>	 appended to the first six tax ID digits provided by the<br/>	 state to calculate the first chec digit.  Therefore, the<br/>	 first and second check digits will be switched before <br/>		 passing the Tax ID into the standard function*/  <br/>		 <br/>		 /*copy off the second check digit*/<br/>		 szWorkStr[1]=szTaxID[7];<br/>		 <br/>		 /*copy first check digit into second check digit*/<br/>		 szTaxID[7]=szTaxID[6];<br/>		 <br/>		 /*copy the second check digit into the first check digit*/<br/>		 szTaxID[6]=szWorkStr[1];<br/>		 <br/>		 jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>			 DIM(lpDSData.szTaxId));<br/>		 <br/>		 jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>			 DIM(lpDSData.szState));<br/>		 <br/>		 <br/>			 /*Load a variable with 0123458 to see if the first character<br/>		 of the Tax ID is one of these values*/<br/>		 jdeStrncpy ((JCHAR *)szControlLet, (const JCHAR *)(_J("0123458")), <br/>			 DIM(szControlLet));<br/>		 <br/>		 <br/>			 /*If the first character is not one of the values 0,1,2,3,4,5,or 8<br/>		 ptr will be a null pointer otherwise ptr will have a value*/<br/>		 ptr = jdeStrchr(szControlLet, szTaxID[0]);<br/>		 <br/>		 /*if the first digit is 0, 1, 2,3,4,5 or 8*/ <br/>		 if (ptr != (JCHAR*) NULL) <br/>		 {<br/>		 /*If the first digit is  0, 1, 2,3,4,5 or 8 then run this<br/>		 validation routine.Load the Data Structure with the appropriate values and<br/>			 call the internal standard tax ID function*/ <br/>			 <br/>			 /*Load Weights*/<br/>			 memcpy(lpDSData.iWeights1, iWgtsBahia1, sizeof(lpDSData.iWeights1));<br/>			 memcpy(lpDSData.iWeights2, iWgtsBahia2, sizeof(lpDSData.iWeights2));<br/>			 <br/>			 /*Load Weights Length*/ <br/>			 lpDSData.iWeightsLength1 = 5;<br/>			 lpDSData.iWeightsLength2 = 6;<br/>			 <br/>			 /*Use Modulus operator 11*/<br/>			 lpDSData.nModulus = 10;<br/>			 <br/>			 /*The Number of Check Digits to be Calculated*/<br/>			 lpDSData.nNoCheckDigits = 2;	<br/>			 <br/>			 /*Call the internal Function */<br/>			 I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			 <br/>			 /* If the internal function has an error it will set an error flag<br/>			 if the error flag is equal to 1 then set a hard error on Tax ID*/ 		<br/>			 if( lpDSData.cErrorFlag == 1)<br/>			 {<br/>				 bError = (BOOL) TRUE;<br/>				 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"),  (LPVOID) NULL);<br/>				 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				 idReturnValue= ER_ERROR;<br/>			 }<br/>			 <br/>			 <br/>		 }<br/>		 else<br/>		 {<br/>		 /*If the first digit is 6, 7, or 9 then run the standard <br/>		 validation routine.Load the Data Structure with the appropriate values and<br/>		 call the internal standard tax ID function (the second digit is still<br/>			 calculated before the first character).*/ <br/>			 <br/>			 /*Load Weights*/<br/>			 memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>			 memcpy(lpDSData.iWeights2, iStandardWeights, sizeof(lpDSData.iWeights2));<br/>			 <br/>			 /*Load Weights Length*/ <br/>			 lpDSData.iWeightsLength1 = 7;<br/>			 lpDSData.iWeightsLength2 = 7;<br/>			 <br/>			 /*Use Modulus operator 11*/<br/>			 lpDSData.nModulus = 11;<br/>			 <br/>			 /*The Number of Check Digits to be Calculated*/<br/>			 lpDSData.nNoCheckDigits = 2;	<br/>			 <br/>			 /*Call the internal Function */<br/>			 I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			 <br/>			 /* If the internal function has an error it will set an error flag<br/>			 if the error flag is equal to 1 then set a hard error on Tax ID*/ 		<br/>			 if( lpDSData.cErrorFlag == 1)<br/>			 {<br/>				 bError = (BOOL) TRUE;<br/>				 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"),  (LPVOID) NULL);<br/>				 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				 idReturnValue= ER_ERROR;<br/>			 }<br/>		 }<br/>		}	<br/>		<br/>		else<br/>		{<br/>/*if the Tax ID length is 9 i.e. seven digits assigned by the state plus 2 check <br/>     digits then proceed with validation*/<br/>	 if (jdeStrlen(szTaxID)==9)<br/>	 {	<br/>	 /*The second check digit is calculated first and then<br/>	 appended to the first seven tax ID digits provided by the<br/>	 state to calculate the first chec digit.  Therefore, the<br/>	 first and second check digits will be switched before <br/>		 passing the Tax ID into the standard function*/  <br/>		 <br/>		 /*copy off the second check digit*/<br/>		 szWorkStr[1]=szTaxID[8];<br/>		 <br/>		 /*copy first check digit into second check digit*/<br/>		 szTaxID[8]=szTaxID[7];<br/>		 <br/>		 /*copy the second check digit into the first check digit*/<br/>		 szTaxID[7]=szWorkStr[1];<br/>		 <br/>		 jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>			 DIM(lpDSData.szTaxId));<br/>		 <br/>		 jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>			 DIM(lpDSData.szState));<br/>		 <br/>		 <br/>			 /*Load a variable with 0123458 to see if the first character<br/>		 of the Tax ID is one of these values*/<br/>		 jdeStrncpy ((JCHAR *)szControlLet, (const JCHAR *)(_J("0123458")), <br/>			 DIM(szControlLet));<br/>		 <br/>		 <br/>			 /*If the first character is not one of the values 0,1,2,3,4,5,or 8<br/>		 ptr will be a null pointer otherwise ptr will have a value*/<br/>		 ptr = jdeStrchr(szControlLet, szTaxID[0]);<br/>		 <br/>		 /*if the first digit is 0, 1, 2,3,4,5 or 8*/ <br/>		 if (ptr != (JCHAR*) NULL) <br/>		 {<br/>		 /*If the first digit is  0, 1, 2,3,4,5 or 8 then run this<br/>		 validation routine.Load the Data Structure with the appropriate values and<br/>			 call the internal standard tax ID function*/ <br/>			 <br/>			 /*Load Weights*/<br/>			 memcpy(lpDSData.iWeights1, iWgtsBahia2, sizeof(lpDSData.iWeights1));<br/>			 memcpy(lpDSData.iWeights2, iWgtsBahia3, sizeof(lpDSData.iWeights2));<br/>			 <br/>			 /*Load Weights Length*/ <br/>			 lpDSData.iWeightsLength1 = 6;<br/>			 lpDSData.iWeightsLength2 = 7;<br/>			 <br/>			 /*Use Modulus operator 11*/<br/>			 lpDSData.nModulus = 10;<br/>			 <br/>			 /*The Number of Check Digits to be Calculated*/<br/>			 lpDSData.nNoCheckDigits = 2;	<br/>			 <br/>			 /*Call the internal Function */<br/>			 I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			 <br/>			 /* If the internal function has an error it will set an error flag<br/>			 if the error flag is equal to 1 then set a hard error on Tax ID*/ 		<br/>			 if( lpDSData.cErrorFlag == 1)<br/>			 {<br/>				 bError = (BOOL) TRUE;<br/>				 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"),  (LPVOID) NULL);<br/>				 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				 idReturnValue= ER_ERROR;<br/>			 }<br/>			 <br/>			 <br/>		 }<br/>		 else<br/>		 {<br/>		 /*If the first digit is 6, 7, or 9 then run the standard <br/>		 validation routine.Load the Data Structure with the appropriate values and<br/>		 call the internal standard tax ID function (the second digit is still<br/>			 calculated before the first character).*/ <br/>			 <br/>			 /*Load Weights*/<br/>			 memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>			 memcpy(lpDSData.iWeights2, iStandardWeights, sizeof(lpDSData.iWeights2));<br/>			 <br/>			 /*Load Weights Length*/ <br/>			 lpDSData.iWeightsLength1 = 8;<br/>			 lpDSData.iWeightsLength2 = 8;<br/>			 <br/>			 /*Use Modulus operator 11*/<br/>			 lpDSData.nModulus = 11;<br/>			 <br/>			 /*The Number of Check Digits to be Calculated*/<br/>			 lpDSData.nNoCheckDigits = 2;	<br/>			 <br/>			 /*Call the internal Function */<br/>			 I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			 <br/>			 /* If the internal function has an error it will set an error flag<br/>			 if the error flag is equal to 1 then set a hard error on Tax ID*/ 		<br/>			 if( lpDSData.cErrorFlag == 1)<br/>			 {<br/>				 bError = (BOOL) TRUE;<br/>				 //jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"),  (LPVOID) NULL);<br/>				 jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				 idReturnValue= ER_ERROR;<br/>			 }<br/>		 }<br/>		}	<br/>		<br/>		else<br/>		{<br/>			/*if the Tax ID is not 8 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		}<br/>		<br/>		<br/> }<br/> <br/> <br/> <br/> /************************************************************************<br/> * Distrito Federal  (DF)<br/> ************************************************************************/<br/> <br/> /*If the State passed in is DF*/ 	<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("DF")),DIM(lpDS.szState)) == 0 ))<br/>	{<br/>		<br/>	/*if the Tax ID length is 13 i.e. two fixed digits (07) plus eight variable<br/>		digits assigned by the state plus 2 check digits then proceed with validation*/	<br/>		if (jdeStrlen(szTaxID)==13)<br/>		{	<br/>			/*The first two digits have to be 07*/<br/>			if((szTaxID[0]==_J('0')) && <br/>				(szTaxID[1]==_J('7')))<br/>			{<br/>			/*Load the Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/ <br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				memcpy(lpDSData.iWeights2, iStandardWeights, sizeof(lpDSData.iWeights2));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				lpDSData.iWeightsLength2 = 7;<br/>				<br/>				<br/>				/*Use Modulus operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*The Number of Check Digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 2;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*If first 3 digits are not 073 set an error*/<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 13 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Mato Grosso  (MT)<br/>	************************************************************************/<br/>	<br/>	/*If the State passed in is MT*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("MT")), DIM(lpDS.szState)) == 0))<br/>	{<br/>	/*If the Tax ID length is 11 i.e. ten digits assigned by the state plus<br/>		1 check digit then proceed with validation*/	<br/>		if (jdeStrlen(szTaxID)==11)<br/>		{<br/>		/*Load the Data Structure with the appropriate values and<br/>			call the internal standard Tax ID function*/ <br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			/*Load Weights*/<br/>			/*BEGIN SAR 8040779*/<br/>           /* memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));*/<br/>            memcpy(lpDSData.iWeights1, iWgtMatoGrosso, sizeof(lpDSData.iWeights1));<br/>			/*END SAR 8040779*/<br/><br/>			/*Load Weights Length*/ <br/>			/*BEGIN SAR 8040779*/<br/>			/*lpDSData.iWeightsLength1 = 7;*/<br/>			lpDSData.iWeightsLength1 = 9;<br/>			/*END SAR 8040779*/<br/>			<br/>			/*Use Modulus Operator 11*/<br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The number of check digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 1;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/* If the internal function has an error it will set an error flag<br/>			if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 11 characters long set an error */<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Minas Gerais  (MG)<br/>	************************************************************************/	<br/>	<br/>	/*If the State passed in is MG*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("MG")),DIM(lpDS.szState)) == 0))<br/>	{<br/>	/*If the Tax ID length is 13 i.e. three variables digits assigned by the state and<br/>	correponding to the city, plus six variable digits assigned by the state, plus two <br/>	variable digits assigned by the state which sequentially corresponds to the company,<br/>		plus two check digits, then run the validation routine*/  <br/>		<br/>		if (jdeStrlen(szTaxID)==13)<br/>		{<br/>			<br/>			<br/>		/*A zero needs to be inserted between the third and fourth characters of the <br/>		Tax ID.  This code creates two strings, one string with characters 1 thru 3 and <br/>			the other with characters 4 thru 13*/ <br/>			<br/>			iCnt = 0;<br/>			iCount2 = 0; <br/>			for (iCount=0;iCount&lt=13;iCount++)<br/>			{<br/>				<br/>				if (iCount &lt=2 )<br/>				{<br/>					<br/>					szConcatTaxID[iCnt] = szTaxID[iCount];<br/>					iCnt++;<br/>				}<br/>				else<br/>				{	<br/>					szConcatTaxID2[iCount2] = szTaxID[iCount];<br/>					iCount2++;<br/>				}<br/>				<br/>			}	<br/>			<br/>			/* create a variable with the value 0*/<br/>			szConcatTaxID[3] = _J('0');<br/>			szConcatTaxID[4] = _J('\0');<br/>			<br/>			/*concatenate the strings together so that the fourth character is a 0*/<br/>			jdeStrcat((JCHAR *) szConcatTaxID, (const JCHAR *) szConcatTaxID2);<br/>			<br/>			/*calculate the check sum of the products of the weights times the tax ID from<br/>			right to left.  For the first check digit MInas Gerais adds the digits of the products<br/>			and not the product values themselves. For instance 10 + 8 would be 1+0+8 = 9*/<br/>			iWgtCnt = 11; <br/>			<br/>			for (iCnt=11;iCnt&gt=0;iCnt--)<br/>			{	<br/>				/*Get the product*/<br/>				iAdd = (((int) szConcatTaxID[iCnt]-_J('0')) * (iWgtMinas[iWgtCnt]));<br/>				<br/>				/*get the quotient and the remainder*/<br/>				fDivide=div(iAdd,10);<br/>				iRemndr=(int) fDivide.rem;<br/>				iInteger=(int) fDivide.quot;<br/>				<br/>				/*add the quotient and the remainder*/<br/>				iAdd = iRemndr + iInteger; <br/>				<br/>				/*total the sum of the digits*/<br/>				iTotal = iTotal + iAdd; <br/>				<br/>				/*decrement the weights count*/<br/>				iWgtCnt--; <br/>				<br/>			}<br/>			<br/>			/*Divide the product total by modulus operator 10*/<br/>			fDivide=div(iTotal,10);<br/>			<br/>			/*Get the modulus (remainder)*/<br/>			iRemndr = 0; <br/>			iRemndr=(int) fDivide.rem;<br/>			<br/>			/* if the remainder is equal to zero then the check digit is equal to 0*/	<br/>			if (iRemndr == 0)<br/>			{<br/>				iCkDig1 = 0;<br/>			}<br/>			else<br/>			{<br/>			/*Standard check digit calculation for the rest of the states<br/>				is to subtract the modulus (remainder) from the modulus (operator)*/<br/>				iCkDig1 = (10-iRemndr);<br/>			}<br/>			<br/>			<br/>			/*If the second check digit passed in and the second check digit <br/>			calculated are different then set an error*/ <br/>			if (iCkDig1 != ((int) szTaxID[11] -_J('0')))<br/>			{	<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>			<br/>			/*If not error then calculate the first check digit*/<br/>			if (!bError) <br/>			{<br/>				<br/>				/*initialize variables*/	<br/>				iAdd = 0; <br/>				iWgtCnt = 11; <br/>				iRemndr = 0;<br/>				<br/>				<br/>				for (iCnt=11;iCnt&gt=0;iCnt--)<br/>				{	<br/>					<br/>				/*Accumulate a sum of the products of Tax ID digits<br/>					times the weights digits*/	<br/>					iAdd = iAdd + (((int) szTaxID[iCnt]-_J('0')) * ( iWgtMinas2[iWgtCnt]));<br/>					<br/>					/*Decrement the weight count*/<br/>					iWgtCnt --; <br/>					<br/>				}<br/>				<br/>				/*Divide the product total by modulus operator 10*/<br/>				fDivide=div(iAdd,11);<br/>				<br/>				/*Getthe modulus (remainder)*/<br/>				iRemndr=(int) fDivide.rem;<br/>				<br/>				<br/>				/* if the remainder is equal to zero then the check digit is equal to 0*/	<br/>				if ((iRemndr == 0) || (iRemndr == 1))<br/>				{<br/>					iCkDig2 = 0;<br/>				}<br/>				else<br/>				{<br/>				/*Standard check digit calculation for the rest of the states<br/>					is to subtract the modulus (remainder) from the modulus (operator)*/<br/>					iCkDig2 = (11-iRemndr);<br/>				}<br/>				<br/>				<br/>				/*If the first check digit passed in and the first check digit <br/>				calculated are different then set an error*/ <br/>				if (iCkDig2 != ((int) szTaxID[12] -_J('0')))<br/>					<br/>				{	<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>					<br/>				}			   <br/>				<br/>			}<br/>			<br/>			<br/>		}<br/>		else				        <br/>		{<br/>			/*if the Tax ID is not 13 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Parana (PR)<br/>	************************************************************************/	<br/>	<br/>	/*If the State passed in is PR*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("PR")),DIM(lpDS.szState)) == 0   ))<br/>	{	<br/>	/*If the Tax ID length is 10 i.e. ten digits assigned by the state plus<br/>		2 check digits then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==10)<br/>		{<br/>		/*Load the Data Structure with the appropriate values and<br/>			call the internal standard tax ID function*/<br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>				DIM(lpDSData.szState));<br/>			<br/>			<br/>			/*Load Weights*/<br/>			memcpy(lpDSData.iWeights1, iWgtParana, sizeof(lpDSData.iWeights1));<br/>			memcpy(lpDSData.iWeights2, iWgtParana, sizeof(lpDSData.iWeights2));<br/>			<br/>			/*Load Weights Length*/ <br/>			lpDSData.iWeightsLength1 = 5;<br/>			lpDSData.iWeightsLength2 = 5;<br/>			<br/>			/*Use Modulus Operator 11*/<br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The number of check digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 2;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/* If the internal function has an error it will set an error flag<br/>			if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*If the Tax ID is not 10 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Pernambuco (PE)<br/>	********************************************************************/<br/>	<br/>	/*If the State passed in is PE*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("PE")), DIM(lpDS.szState)) == 0   ))<br/>	{<br/>	/*If the Tax ID length is 14 i.e. Thirteen digits assigned by the state plus<br/>		1 check digits then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==14)<br/>		{<br/>		/*Load the Data Structure with the appropriate values and<br/>			call the internal standard tax ID function*/<br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>				DIM(lpDSData.szState));<br/>			<br/>			<br/>			/*Load Weights*/<br/>			memcpy(lpDSData.iWeights1, iWgtPernam, sizeof(lpDSData.iWeights1));<br/>			memcpy(lpDSData.iWeights2, iWgtPernam, sizeof(lpDSData.iWeights2));<br/>			<br/>			/*Load Weights Length*/ <br/>			lpDSData.iWeightsLength1 = 12;<br/>			lpDSData.iWeightsLength2 = 12;<br/>			<br/>			/*Use Modulus Operator 11*/<br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The number of check digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 1;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/* If the internal function has an error it will set an error flag<br/>			if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/* Begin Modification SAR 8819862 */<br/>			if (jdeStrlen(szTaxID)==9)<br/>			{<br/>					/*Load the Data Structure with the appropriate values and<br/>					call the internal standard tax ID function*/<br/>					jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>								DIM(lpDSData.szTaxId));<br/>			<br/>					jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>								DIM(lpDSData.szState));<br/>					<br/>			<br/>					/*Load Weights*/<br/>					memcpy(lpDSData.iWeights1, iWgtPernam2, sizeof(lpDSData.iWeights1));<br/>					memcpy(lpDSData.iWeights2, iWgtPernam3, sizeof(lpDSData.iWeights2));<br/>					<br/>					/*Load Weights Length*/ <br/>					lpDSData.iWeightsLength1 = 6;<br/>					lpDSData.iWeightsLength2 = 7;<br/>					<br/>					/*Use Modulus Operator 11*/<br/>					lpDSData.nModulus = 11;<br/>					<br/>					/*The number of check digits to be calculated*/<br/>					lpDSData.nNoCheckDigits = 2;	<br/>					<br/>					/*Call the internal Function */<br/>					I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>					<br/>					/* If the internal function has an error it will set an error flag<br/>					if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>					if( lpDSData.cErrorFlag == 1)<br/>					{<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1, _J("400C"), (LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>						idReturnValue= ER_ERROR;<br/>					}<br/>			}<br/>			else<br/>			{<br/>				/* End Modification SAR 8819862 */<br/>				/*if the Tax ID is not 15 characters long set an error */<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				/* Begin Modification SAR 8819862 */<br/>			}<br/>			/* End Modification SAR 8819862 */<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Rio de Janiero  (RJ)<br/>	************************************************************************/	<br/>	<br/>	/*If the State passed in is RJ*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("RJ")), DIM(lpDS.szState)) == 0   ))<br/>	{<br/>	/*If the Tax ID length is 8 i.e. seven digits assigned by the state plus<br/>		1 check digit then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==8)<br/>		{<br/>		/*Load the Data Structure with the appropriate values and<br/>			call the internal standard tax ID function*/<br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			/*Load Weights*/<br/>			memcpy(lpDSData.iWeights1, iWgtRioDeJ, sizeof(lpDSData.iWeights1));<br/>			<br/>			/*Load Weights Length*/ <br/>			lpDSData.iWeightsLength1 = 6;<br/>			<br/>			/*Use Modulus Operator 11*/<br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The number of check digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 1;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/* If the internal function has an error it will set an error flag<br/>			if the error flag is equal to 1 then set a hard error on Tax ID*/ <br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 8 characters long then set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), 	(LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	<br/>	/************************************************************************<br/>	* Rio Grande do Sul  (RS)<br/>	************************************************************************/	<br/>	<br/>	<br/>	/*If the State passed in is RS*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("RS")), DIM(lpDS.szState)) == 0 ))<br/>	{<br/>	/*If the Tax ID length is 10 i.e. three digits assigned by the state corresponding<br/>	to the city, plus six variable digits assigned by the state plus<br/>		1 check digit, then proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==10)<br/>		{<br/>		/*The first three characters have to be within the range of 001 through 467. <br/>			Therefore put the first characters of the Tax ID in a substring*/<br/>			<br/>			iCnt = 0; <br/>			for(iCount = 0; iCount&lt=2; iCount++)<br/>			{<br/>				szConcat[iCnt] = szTaxID[iCount];<br/>				iCnt++;<br/>				<br/>			}<br/>			<br/>			szConcat[3] = _J('\0'); <br/>			<br/>			/*Call the Convert String to Numeric to convert these three characters<br/>			into a numeric value in order to evaluate its value in terms of this range*/<br/>			jdeStrncpy((JCHAR *)dsConvertStringToNumeric.szGenericString, (const JCHAR *) szConcat, <br/>				DIM(dsConvertStringToNumeric.szGenericString));<br/>			<br/>			jdeCallObject(_J("ConvertStringToNumeric"),<br/>				NULL,<br/>				lpBhvrCom, lpVoid, <br/>				(LPVOID)&dsConvertStringToNumeric,<br/>				(CALLMAP*)NULL, (int)0, (JCHAR*)NULL,<br/>				(JCHAR*)NULL, (int)0);<br/>			<br/>			MathCopy (&mnSubstring,&dsConvertStringToNumeric.mnNumericValue);<br/>			<br/>			MathNumericToInt (&mnSubstring, &iTaxIDSubstr);<br/>			<br/>			/*If the first three digits are within the range of 001 to 467 (including 001 <br/>			and	467) then run the standard validation routine*/<br/>			<br/>			if ((iTaxIDSubstr &gt= 001)  && (iTaxIDSubstr &lt= 467))<br/>			{		<br/>			/*Load the Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*The Number of Check Digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/<br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>			/*If first three digits are not within the range of <br/>				001 to 467 set an error*/<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 10 characters long set an error*/<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>		<br/>	}<br/>	<br/>	/************************************************************************<br/>	* Sao Paulo  (SP)<br/>	************************************************************************/	<br/>	/* There are two valid formats of Tax IDs for Sao Paolo: one for industries<br/>	and another for agricultural producers.  Industry Tax IDs are twelve digits total, <br/>	where the 9th and 12th characters are the check digits.  Agricultural <br/>	producer Tax IDs start with the letter P followed by a zero, followed<br/>	by seven variable digits plus the check digit, plus three digits which<br/>	are not part of the check digit calculation, for a total of thirteen<br/>	characters in length.*/<br/>	<br/>	/*If the State passed in is SP*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("SP")), DIM(lpDS.szState)) == 0 ))<br/>	{	<br/>	/*If the Tax ID length is 12 (Industry Tax IDs) or if<br/>	the Tax ID length is 13 (Argicultural Producer Tax ID's then<br/>	run the validation (the length is compensated by 1 character<br/>		for the null string)*/<br/>		<br/>		if ((jdeStrlen(szTaxID)==12) || (jdeStrlen(szTaxID)==13)) <br/>		{<br/>			/*Industry Tax ID validation*/<br/>			if (jdeStrlen(szTaxID)==12)<br/>			{<br/>				<br/>				<br/>				iWgtCnt = 7; <br/>				<br/>				<br/>				/* To calculate the first check digit use the first 8 digits of the<br/>				Tax ID. The weights and the tax ID are read from right to left.  Each<br/>				digit in the weights is multiplied by a corresponding tax ID digit.<br/>				The products are summed and then the total sum of the products is<br/>				divided by the modulus (operator).  The modulus (remainder) is then <br/>				obtained and then check digit is calculated by subtracting the modulus <br/>				(remainder) from the modulus. For the Industry Tax ID, the first eight <br/>				digits are used since the first check digit is the ninth digit. The<br/>				check digit is the right most digit of the result of modulus 11 <br/>				of the sum of the products. The second check digit is calculated by <br/>				using all of the digits in the Tax ID up to and including the 11th digit <br/>				(including the first check digit)*/ 			<br/>				<br/>				for (iCnt=7;iCnt&gt=0;iCnt--)<br/>				{	<br/>					<br/>					<br/>				/*Accumulate a sum of the products of Tax ID digits<br/>					times the weights digits*/<br/>					iAdd = iAdd + ((szTaxID[iCnt]-_J('0')) * iWgtsSaoInd[iWgtCnt]);<br/>					iWgtCnt --; <br/>					<br/>				}<br/>				<br/>				<br/>				/*Divide the product total by modulus operator 10*/<br/>				fDivide=div(iAdd,11);<br/>				<br/>				/*Get the modulus (remainder)*/<br/>				iRemndr=(int) fDivide.rem;<br/>				<br/>				/*The check digit is the righter most digit of the modulus 11 (remainder)<br/>				- the remainder cannot be any more than 2 digits*/<br/>				<br/>				iCkDig1 = iRemndr%10;<br/>				<br/>				/*If the first check digit passed in and the first check digit <br/>				calculated are different then set an error*/ <br/>				if(iCkDig1 != ((int) szTaxID[8]-_J('0')))<br/>					<br/>				{	<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>				<br/>				/*If not error then calculate the second check digit*/<br/>				if (!bError) <br/>				{<br/>					<br/>					iAdd = 0; <br/>					iWgtCnt = 10; <br/>					iRemndr = 0;<br/>					<br/>					<br/>					for (iCnt=10;iCnt&gt=0;iCnt--)<br/>					{	<br/>						<br/>						<br/>					/*Accumulate a sum of the products of Tax ID digits<br/>						times the weights digits*/<br/>						iAdd = iAdd + ((szTaxID[iCnt]-_J('0')) * iWgtsSaoInd2[iWgtCnt]);<br/>						iWgtCnt --; <br/>						<br/>					}<br/>					<br/>					<br/>					/*Divide the product total by modulus operator 10*/<br/>					fDivide=div(iAdd,11);<br/>					<br/>					/*Get the modulus (remainder)*/<br/>					iRemndr=(int) fDivide.rem;<br/>					<br/>					/*The check digit is the righter most digit of the modulus 11 (remainder)<br/>					- the remainder cannot be any more than 2 digits*/<br/>					iCkDig2 = iRemndr%10;<br/>					<br/>					/*If the second check digit passed in and the second check digit <br/>					calculated are different then set an error*/ <br/>					if(iCkDig2 != ((int) szTaxID[11]-_J('0')))<br/>						<br/>					{	<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>						idReturnValue= ER_ERROR;<br/>					}<br/>					<br/>					<br/>				}<br/>				<br/>			}<br/>			/*If the string length is not 12 then it must be 13 and therefore an <br/>			Agricultural Producer Tax ID. The following is the Agricultural Producer <br/>			State Tax ID. It only has 1 check digit. The check digit is the 10th digit <br/>			in the Tax ID. The last three digits are not used in the tax ID calculation. <br/>			The check digit is the right most digit of the result of modulus 11 of the <br/>			sum of the products. */<br/>			else<br/>			{	<br/>			/*The first character for Agricultural Producer Tax ID's<br/>				must be equal to the letter P*/<br/>				if ((szTaxID[0]==_J('P')) && (szTaxID[1]==_J('0')))<br/>				{<br/>					<br/>					iAdd = 0; <br/>					iCnt=0;<br/>					iWgtCnt = 7; <br/>					<br/>					<br/>					/* The first character of the Tax ID is P therefore the counter has to<br/>					be greater than 0 NOT greater then equal to 0*/ <br/>					for (iCnt=8;iCnt&gt0;iCnt--)<br/>					{	<br/>						<br/>						<br/>					/*Accumulate a sum of the products of Tax ID digits<br/>						times the weights digits*/<br/>						iAdd = iAdd + ((szTaxID[iCnt]-_J('0')) * iWgtsSaoAgr[iWgtCnt]);<br/>						iWgtCnt --; <br/>						<br/>					}<br/>					/*Divide the product total by modulus operator 10*/<br/>					fDivide=div(iAdd,11);<br/>					<br/>					/*Get the modulus (remainder)*/<br/>					iRemndr=(int) fDivide.rem;<br/>					<br/>					/*The check digit is the righter most digit of the modulus 11 (remainder)<br/>					- the remainder cannot be any more than 2 digits*/<br/>					<br/>					iCkDig1 = iRemndr%10;<br/>					<br/>					/*If the first check digit passed in and the first check digit <br/>					calculated are different then set an error*/ <br/>					if(iCkDig1 != ((int) szTaxID[9]-_J('0')))<br/>						<br/>					{	<br/>						bError = (BOOL) TRUE;<br/>						//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , 	_J("400C"), 	(LPVOID) NULL);<br/>						jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>						idReturnValue= ER_ERROR;<br/>					}<br/>					<br/>					<br/>				}<br/>				else<br/>				{<br/>				/* if the string length is 13 and first two character are not<br/>					the letter P and zero then set an error*/<br/>					<br/>					<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), 	(LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>					<br/>				}<br/>				<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>		/*If the tax ID length is not 12 or 13 then it does not meet the length<br/>		for an Industrial tax ID OR an Agricultural Producer Tax ID therefore<br/>		set an error*/<br/>		{<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , 	_J("400C"), (LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>			<br/>		}<br/>		<br/>		<br/>	}<br/>	<br/>	<br/>	<br/>	/************************************************************************<br/>	* Tocantins  (TO)<br/>	************************************************************************/	<br/>	<br/>	/*If the State passed in is TO*/ <br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("TO")),DIM(lpDS.szState)) == 0 ))<br/>	{<br/>		<br/>	/*If today's date is earlier than 01/01/2004, the old tax ID format and new tax<br/>		  ID format can be used.  If today's date is after 01/01/2004 the new tax ID format<br/>		must be used.*/<br/>		DeformatDate (&jdTocNewIDBaseDateFormat, _J("01/01/2004"), _J("OSASE"));<br/>		iDateDifference = DateDifference(&jdToday, &jdTocNewIDBaseDateFormat);<br/>		<br/>		/*If the Tax ID length is 11 i.e. ten digits assigned by the state plus<br/>		1 check digit then proceed with validation*/<br/>		if ((jdeStrlen(szTaxID)==11) && (iDateDifference &gt 0)) /*Old Tax ID format */<br/>		{<br/>			<br/>			/*The third and fourth characters have to be 01, 02, 03 or 99*/<br/>			if((szTaxID[2]==_J('0')) && (szTaxID[3]==_J('1')) ||<br/>				(szTaxID[2]==_J('0')) && (szTaxID[3]==_J('2')) ||<br/>				(szTaxID[2]==_J('0')) && (szTaxID[3]==_J('3')) ||<br/>				(szTaxID[2]==_J('9')) && (szTaxID[3]==_J('9')))<br/>			{<br/>				<br/>				<br/>			/*Load the Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iWgtTocantins, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 9;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*The number of Check Digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/<br/>				if( lpDSData.cErrorFlag == 1)<br/>				{<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , 	_J("400C"), 	(LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>				<br/>			}<br/>			else<br/>			{<br/>				/*The third and fourth digits are not 01,02,03 or 99 set an error*/<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, 	(ID) IDERRszTaxId2_1  , 	_J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>				<br/>			}<br/>			<br/>		}<br/>		else<br/>			if (jdeStrlen(szTaxID)==9) /* New Tax ID format */<br/>			{<br/>				<br/>			/*Load the Data Structure with the appropriate values and<br/>				call the internal standard tax ID function*/<br/>				jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>					DIM(lpDSData.szTaxId));<br/>				<br/>				/*Load Weights*/<br/>				memcpy(lpDSData.iWeights1, iWgtTocantins2, sizeof(lpDSData.iWeights1));<br/>				<br/>				/*Load Weights Length*/ <br/>				lpDSData.iWeightsLength1 = 7;<br/>				<br/>				/*Use Modulus Operator 11*/<br/>				lpDSData.nModulus = 11;<br/>				<br/>				/*The number of Check Digits to be calculated*/<br/>				lpDSData.nNoCheckDigits = 1;	<br/>				<br/>				/*Call the internal Function */<br/>				I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>				<br/>				/* If the internal function has an error it will set an error flag<br/>				if the error flag is equal to 1 then set a hard error on Tax ID*/<br/>				if(lpDSData.cErrorFlag == 1)<br/>				{<br/>					/*if the Tax ID is not 11 characters long set an error */<br/>					bError = (BOOL) TRUE;<br/>					//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , 	_J("400C"), 	(LPVOID) NULL);<br/>					jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>					idReturnValue= ER_ERROR;<br/>				}<br/>			}<br/>			else		<br/>			{<br/>				/*if the Tax ID is not 11 characters long set an error */<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>	}<br/>	<br/>	<br/>	<br/>	<br/>	/*****************************************************************************<br/>	* Amazonas - (AM), Ceara (CE), Espirito Santos (ES), Paraiba (PB), Piaui (PI),<br/>	* Rio Grande do Norte (RN), Santa Catarina (SC), Sergipe (SE)<br/>	******************************************************************************/		<br/>	<br/>	/*if the State passed in is AM,CE, ES, PB PI, RN, SC, or SE then run the following <br/>	validation routine */<br/>	<br/>	if((jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("AM")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("CE")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("ES")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("PB")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("PI")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("RN")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("SC")),DIM(lpDS.szState)) == 0   )||<br/>		(jdeStrncmp((JCHAR *)(lpDS.szState),(JCHAR *)(_J("SE")),DIM(lpDS.szState)) == 0   )) <br/>	{<br/>	/*if the Tax ID length is 9 i.e. eight digits plus 1 check digit then <br/>		proceed with validation*/<br/>		if (jdeStrlen(szTaxID)==9)<br/>		{<br/>		/*Load the  Data Structure with the appropriate values and<br/>			call the internal standard tax ID function  */ <br/>			<br/>			jdeStrncpy ((JCHAR *)lpDSData.szTaxId, (const JCHAR *)(szTaxID), <br/>				DIM(lpDSData.szTaxId));<br/>			<br/>			jdeStrncpy ((JCHAR *)lpDSData.szState, (const JCHAR *)(lpDS.szState), <br/>				DIM(lpDSData.szState));<br/>			<br/>			/*Load Weights*/<br/>			memcpy(lpDSData.iWeights1, iStandardWeights, sizeof(lpDSData.iWeights1));<br/>			<br/>			/*Load Weights Length*/ <br/>			lpDSData.iWeightsLength1 = 7;<br/>			<br/>			/*Use Modulus Operator 11*/ <br/>			lpDSData.nModulus = 11;<br/>			<br/>			/*The Number of Check Digits to be calculated*/<br/>			lpDSData.nNoCheckDigits = 1;	<br/>			<br/>			/*Call the internal Function */<br/>			I5576600_StandardTaxIDValidation(lpBhvrCom, lpVoid, &lpDSData);<br/>			<br/>			/*Load the  Data Structure with the appropriate values and<br/>			call the internal standard tax ID function  */ <br/>			if( lpDSData.cErrorFlag == 1)<br/>			{<br/>				bError = (BOOL) TRUE;<br/>				//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1  , _J("400C"), (LPVOID) NULL);<br/>				jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>				idReturnValue= ER_ERROR;<br/>			}<br/>			<br/>		}<br/>		else<br/>		{<br/>			/*if the Tax ID is not 9 characters long */<br/>			bError = (BOOL) TRUE;<br/>			//jdeErrorSet (lpBhvrCom, lpVoid, (ID) IDERRszTaxId2_1   ,_J("400C"), 	(LPVOID) NULL);<br/>			jdeStrncpyTerminate( CdErro,  (const JCHAR *) (_J("400C")),	 DIM(_J("400C")));<br/>			idReturnValue= ER_ERROR;<br/>		}<br/>	}<br/> }<br/>	<br/>	<br/>	/************************************************************************<br/>	* Function Clean Up<br/>	************************************************************************/<br/>	<br/>	if (hRequestV0101BR != NULL)<br/>	{<br/>		JDB_CloseView(hRequestV0101BR);<br/>	}<br/>	<br/>	return (ER_SUCCESS);<br/>}<br/><br/><br/><br/>/* Internal function comment block */<br/>/**************************************************************************<br/>*   Function:  I7602122_StandardTaxIDValidation	  // Replace "xxxxxxx" with source file number<br/>*                           // and "a" with the function name<br/>*      Notes:<br/>*<br/>*    Returns: <br/>*<br/>* Parameters:<br/>**************************************************************************/<br/><br/>ID I5576600_StandardTaxIDValidation (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD7602122I lpDSData)<br/>{<br/>	<br/>	<br/>   /************************************************************************<br/>    *  Variable declarations<br/>	************************************************************************/<br/>	BOOL			bError		  = (BOOL)FALSE;<br/>	ID				idReturnValue = ER_SUCCESS;<br/>	div_t			fDiv;<br/>	MATH_NUMERIC	mnOutputNumeric;<br/>	JCHAR			szTaxID[21]   = { _J('\0') };<br/>	int 			iTaxNumber; 	<br/>	int 			iWeightsLength =0; <br/>	int 			iTaxIdLength = 0;<br/>	int 			iCheckDigit1 =	0; <br/>	int 			iCheckDigit2 =	0;<br/>	int 			iTaxIDCount = 0;<br/>	int 			iWeightsCount = 0;<br/>	int 			iRem =0;<br/>	int 			iCalc  = 0; <br/>	int 			iTaxID = 0;<br/>	int 			iModulus = 0;<br/>	int 			iModulus2 = 0;<br/>	short			iWeights1[15] = { _J('\0') };<br/>	short			iWeights2[15] = { _J('\0') };<br/>	<br/>	<br/>	/************************************************************************<br/>	* Declare structures<br/>	************************************************************************/<br/>	DSD4000481	dsConvertStringToNumeric; /* Convert String to Numeric - B4000770 */<br/>	<br/>	/************************************************************************<br/>	* Set pointers<br/>	************************************************************************/<br/>	memset(iWeights1, 0, sizeof(iWeights1));<br/>	memset(iWeights2, 0, sizeof(iWeights2));<br/>	<br/>	<br/>	/************************************************************************<br/>	* Main Processing<br/>	************************************************************************/<br/>	/*initialize math numeric values*/<br/>	ZeroMathNumeric(&mnOutputNumeric);<br/>	<br/>	if (!bError) <br/>	{	<br/>		/*Copy the State Tax ID into a string to be used throughout the function*/<br/>		jdeStrncpy(szTaxID,(const JCHAR *) (lpDSData-&gtszTaxId), DIM(szTaxID));<br/>		<br/>		/*Calculate the Tax ID Lengths*/ <br/>		<br/>		if (lpDSData-&gtnNoCheckDigits == 1)<br/>		{	<br/>		/*If one check digit is to be calculated then the <br/>		string length is Tax ID length -2 (because it will be used<br/>			as a counter which starts at 0)*/<br/>			iTaxIdLength = (jdeStrlen(szTaxID) -2);<br/>			<br/>			<br/>		}<br/>		else<br/>		{	<br/>		/*If two check digits are to be calculated then the <br/>		string length is Tax ID length -3 (because it will be used<br/>			as a counter which starts at 0)*/<br/>			iTaxIdLength = (jdeStrlen(szTaxID) -3);<br/>			<br/>		}<br/>		<br/>		/* Delete all the blanks at the right */ <br/>		jdeStripTrailingBlanks(szTaxID);<br/>		<br/>		<br/>		/*copy Modulus Operator 1 and 2 into variables */<br/>		iModulus = lpDSData-&gtnModulus;<br/>		iModulus2 =lpDSData-&gtnModulus2; <br/>		<br/>		/*copy weights into variables*/<br/>		memcpy(iWeights1, lpDSData-&gtiWeights1, sizeof(iWeights1));<br/>		memcpy(iWeights2, lpDSData-&gtiWeights2, sizeof(iWeights2));<br/>		<br/>		<br/>		/*Put the weights length into a variable*/<br/>		iWeightsLength = lpDSData-&gtiWeightsLength1;<br/>		<br/>		<br/>		/*The weights and the tax ID are read from right to left.  Each<br/>		digit in the weights is multiplied by a corresponding tax ID digit.<br/>		The products are summed and then the total sum of the products is<br/>		divided by the modulus (operator).	The modulus (remainder) is then <br/>		obtained and then check digit is calculated by subtracting the modulus <br/>		(remainder) from the modulus.  Some variations have been created to <br/>		accommodate the routines of certain states*/<br/>		iWeightsCount =  iWeightsLength; <br/>		<br/>		for (iTaxIDCount=iTaxIdLength;iTaxIDCount&gt=0;iTaxIDCount--)<br/>		{	<br/>			<br/>			<br/>			<br/>			/*The standard calculation adds the products of the multiplication*/<br/>			iCalc = (((int) szTaxID[iTaxIDCount]-_J('0')) * (iWeights1[iWeightsCount]) + iCalc);<br/>			<br/>			/*Decrement the weight count*/<br/>			iWeightsCount --; <br/>			<br/>			/*if the weights are shorter than the Tax ID then reset the counter<br/>			so that the weights start from the farthest right character again -<br/>			the weights and the tax ID are read right to left*/<br/>			if	(iWeightsCount &lt0)<br/>			{<br/>				iWeightsCount =  iWeightsLength;<br/>				<br/>			}<br/>		}	<br/>		/*The total of the products is divided by the modulus (operator), usually either<br/>		10 or 11 and then the modulus (remainder) is taken and usually the check digit is<br/>		obtained by subtracting the modulus (remainder).  Alagoas, Amapa and Goias have<br/>		their own routines to calculate the check digit off of the modulus (remainder) <br/>		Alagoas and Goias do not subtract the modulus (remainder) from the modulus operator used<br/>		(i.e. 10 or 11) to get the check digit.  They use the value of the modulus 11 itself<br/>		to detemine the check digit.  Amapa does subtract the modulus (remainder) from the <br/>		modulus (operator) however the value P caluculated in the main is added to the sum<br/>		of the products before the modulus is taken. */ <br/>		<br/>		<br/>		/*Alagoas and Rio Grande do Norte*/<br/>		if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("AL")),DIM(lpDSData-&gtszState)) == 0 ) ||<br/>			(jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("RN")),DIM(lpDSData-&gtszState)) == 0 ))<br/>		{	<br/>			/*multiply the sum of the products times 10*/	<br/>			iCalc = iCalc*10;<br/>			<br/>			fDiv=div(iCalc,lpDSData-&gtnModulus);<br/>			iRem=(int)fDiv.rem;<br/>			<br/>			/*if the remainder is zero the check digit is 0 otherwise the check digit is <br/>			equal to the calculated remainder*/<br/>			if (iRem == 10)<br/>			{<br/>				iCheckDigit1 = 0;<br/>			}<br/>			else<br/>			{<br/>				<br/>				iCheckDigit1 = iRem;<br/>			}	<br/>			<br/>			<br/>		}<br/>		else <br/>			/*Rondonia and Pernambuco*/<br/>			/* Begin Modification SAR 8819862 */<br/>			/*if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("RO")),DIM(lpDSData-&gtszState)) == 0 )||<br/>				(jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("PE")),DIM(lpDSData-&gtszState)) == 0 ))<br/>			*/<br/>			if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("RO")),DIM(lpDSData-&gtszState)) == 0 )||<br/>				((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("PE")),DIM(lpDSData-&gtszState)) == 0 ) &&<br/>				(jdeStrlen(szTaxID)!=9) ))<br/>			/* End Modification SAR 8819862 */				<br/>			{	<br/>				/*Divide by the Modulus Operator*/<br/>				fDiv=div(iCalc,lpDSData-&gtnModulus);<br/>				<br/>				/*Get the modulus (remainder)*/<br/>				iRem=(int) fDiv.rem;<br/>				<br/>				/*For Rondonia and Pernambuco if the check digit calculated is 10 then then<br/>				the check digit is equal to 0, otherwise the check digit is <br/>				equal to 1 which is the same as the right most character<br/>				of the check digit. Modulus 10 will get the right most character*/ <br/>				<br/>				iCheckDigit1 = (iModulus-iRem);<br/>				iCheckDigit1 = iCheckDigit1%10;<br/>				<br/>			}<br/>			else<br/>				/*Roraima*/<br/>				if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("RR")),DIM(lpDSData-&gtszState)) == 0 ))<br/>				{<br/>					/*Divide by the Modulus Operator*/<br/>					fDiv=div(iCalc,lpDSData-&gtnModulus);<br/>					<br/>					/*Get the modulus (remainder)*/<br/>					iRem=(int) fDiv.rem;<br/>					<br/>					/*the check digit is equal to the remainder*/<br/>					iCheckDigit1 = iRem;<br/>					<br/>				}<br/>				else<br/>					/*Amapa*/<br/>					if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("AP")),<br/>						DIM(lpDSData-&gtszState)) == 0   ))<br/>						<br/>						<br/>		/*Amapa adds the value of P calculated in the main function<br/>						into the sum of the products before it does the modulus. If the<br/>						modulus remainder is 10 the check digit is equal to 0, if the modulus<br/>						remainder is 11 then the check digit is the value of D caluculated<br/>						in the main program. Otherwise the the check digit is the modulus <br/>						operator minus the modulus remainder.*/ 			<br/>					{<br/>						<br/>						/* Add the Value of P into the the sum of the products*/<br/>						iCalc = iCalc + lpDSData-&gtiAmapaP; <br/>						<br/>						/*Divide by the modulus (operator)*/<br/>						fDiv=div(iCalc,iModulus);<br/>						<br/>						/*Get the modulus (remainder)*/<br/>						iRem=(int) fDiv.rem;<br/><br/>						/* Sar 7166644  Correct Code in accordance with algorithm */<br/><br/>						/*the check digit is the modulus operator minus the modulus remainder*/ <br/>						iCheckDigit1 = (iModulus-iRem);<br/>						<br/>						/*	if the check digit equals 10 then set the check digit to 0*/<br/>						if (iCheckDigit1 == 10) <br/>						{<br/>							iCheckDigit1 = 0;<br/>						}<br/>						/*Else if the check digit equals 11 set the check digit equal to variable<br/>						"D" which was calculated in the main routine for Amapa*/<br/>						else <br/>							if (iCheckDigit1 == 11)<br/>							{<br/>								iCheckDigit1 = lpDSData-&gtiAmapaD;<br/>							}<br/>													<br/>					}<br/>					<br/>					else<br/>						/*Goias*/ <br/>						if((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("GO")),<br/>							DIM(lpDSData-&gtszState)) == 0   ))<br/>							<br/>						{<br/>							/*Divide by the modulus (operator)*/<br/>							fDiv=div(iCalc,iModulus);<br/>							<br/>							/*Get the modulus (remainder)*/<br/>							iRem=(int) fDiv.rem;<br/>							<br/>							if	(iRem == 1)<br/>							{<br/>							/*Convert the tax ID from a string to a number to determine if it<br/>							is in the range between 10103105 and 10119997 (including 10103105 and<br/>								10119997)*/<br/>								jdeStrncpy((JCHAR *)dsConvertStringToNumeric.szGenericString, (const JCHAR *) (szTaxID), <br/>									DIM(dsConvertStringToNumeric.szGenericString));<br/>								<br/>								jdeCallObject(_J("ConvertStringToNumeric"),<br/>									NULL,<br/>									lpBhvrCom, lpVoid, <br/>									(LPVOID)&dsConvertStringToNumeric,<br/>									(CALLMAP*)NULL, (int)0, (JCHAR*)NULL,<br/>									(JCHAR*)NULL, (int)0);<br/>								<br/>								MathCopy (&mnOutputNumeric,&dsConvertStringToNumeric.mnNumericValue);<br/>								<br/>								<br/>								MathNumericToInt (&mnOutputNumeric, &iTaxID);<br/>								<br/>								/*if the Tax ID is within the range of 10103105 and 10119997<br/>								(including 10103105 and 10119997)*/<br/>								<br/>								if ( (iTaxID &gt= 10103105)  && (iTaxID &lt= 10119997))<br/>									<br/>								{ <br/>									/*The check digit is equal to 1*/<br/>									iCheckDigit1 = 1;<br/>								}<br/>								else<br/>								{<br/>									/*else the check digit is equal to 0*/<br/>									iCheckDigit1 = 0;<br/>								}<br/>								<br/>							}<br/>							else<br/>							/*If the remainder is 0 then the check digit is 0. If the modulus <br/>							(remainder) is not equal to 1 then the check digit is obtained through <br/>							the standard process of subtracting the modulus (remainder) from the <br/>							modulus (operator) i.e. 10 or 11*/ <br/>							if (iRem == 0) <br/>							{<br/>								iCheckDigit1 = 0;<br/>							}<br/>							else<br/>							{<br/>								/*If the remainder is noStandard check digit calculation is to subtract the modulus (remainder) from the modulus (operator)*/<br/>								iCheckDigit1 = (iModulus-iRem);<br/>							}<br/>							<br/>						}<br/>						else<br/>						{<br/>							<br/>							/*Divide by the modulus (operator)*/<br/>							fDiv=div(iCalc,iModulus);<br/>							<br/>							/*Get the modulus (remainder)*/<br/>							iRem=(int) fDiv.rem;<br/>							<br/>							/* if the Modulus operator is 11 and the remainder is<br/>							equal to 0 or 1 then the check digit is equal to 0*/<br/>							if ((iModulus == 11) && ((iRem == 0) || (iRem == 1)))<br/>							{<br/>								iCheckDigit1 = 0;<br/>							}<br/>							else<br/>							/*else if the modulus operator is equal to 10 and the remainder is<br/>							equal to 0 then the check digit is equal to 0*/<br/>							if ((iModulus == 10) && (iRem == 0))<br/>							{<br/>								iCheckDigit1 = 0;<br/>							}<br/>							else<br/>							{<br/>							/* use the Standard check digit calculation which is<br/>								to subtract the modulus (remainder) from the modulus (operator)*/<br/>								iCheckDigit1 = (iModulus-iRem);<br/>							}<br/>							<br/>						}<br/>						<br/>						<br/>						/*If the check digit calculated is not equal to the <br/>						check digit passed in then set an error flag to be read by<br/>						the main program where a hard error will set*/<br/>						if (iCheckDigit1 != ((int) szTaxID[iTaxIdLength+1] -_J('0')))<br/>							<br/>						{	<br/>							lpDSData-&gtcErrorFlag = 1;<br/>							bError = (BOOL) TRUE;<br/>							<br/>						}<br/>						<br/>						/*If the check digit value passed in is 2, meaning that two check<br/>						digits should be calculated then and there are no errors then<br/>						do the following calculation*/<br/>						<br/>						if ((lpDSData-&gtnNoCheckDigits ==2) && (!bError))<br/>						{	<br/>							<br/>						/*if Modulus 2 (operator) is null (meaning that the number to divide by is blank<br/>						or zero and a second check digit is supposed to be calculated then<br/>							make the second modulus (operator) equal to the first modulus (operator)*/<br/>							if ((lpDSData-&gtnNoCheckDigits ==2) && (iModulus2 == 0))<br/>							{<br/>								<br/>								iModulus2 = iModulus;<br/>								<br/>							}<br/>							<br/>							<br/>							/*Re-initialize variables*/<br/>							iWeightsLength = lpDSData-&gtiWeightsLength2;; <br/>							iCalc = 0; <br/>							iTaxIDCount=0;<br/>							iWeightsCount = iWeightsLength; <br/>							iTaxNumber	  = 0;<br/>							<br/>							<br/>							/* the second check digit is calcuated through the same<br/>							process as the first check digit.  The weights and the tax<br/>							ID are read from right to left and each Tax ID digit is <br/>							multiplied by a corresponding Weights digit.  The products<br/>							of these digits are accumulated and the product total is divided<br/>							by the modulus (operator i.e. 10 or 11) then the modulus (remainder)<br/>							is taken from this division and the modulus (remainder) is <br/>							subtracted from the modulus (operator) ex: 11 - remainder*/<br/>							<br/>							<br/>							<br/>							for (iTaxIDCount=(iTaxIdLength+1);iTaxIDCount&gt=0;iTaxIDCount--)<br/>							{	<br/>								<br/>								/*The standard calculation adds the products of the multiplication*/<br/>								iCalc = iCalc + (((int) szTaxID[iTaxIDCount]-_J('0')) * (iWeights2[iWeightsCount]));<br/>								<br/>								/*Decrement the weight count*/<br/>								iWeightsCount --; <br/>								<br/>								/*if the weights are shorter than the Tax ID then reset the counter<br/>								so that the weights start from the farthest right character again -<br/>								the weights and the tax ID are read right to left*/<br/>								if	(iWeightsCount &lt0)<br/>								{<br/>									iWeightsCount =  iWeightsLength;<br/>									<br/>								}<br/>							}<br/>							<br/>							<br/>							/*Pernambuco*/<br/>							/* Begin Modification SAR 8819862 */<br/>							/*if(jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("PE")),DIM(lpDSData-&gtszState)) == 0)*/<br/>							if ((jdeStrncmp((JCHAR *)(lpDSData-&gtszState),(JCHAR *)(_J("PE")),DIM(lpDSData-&gtszState)) == 0) &&<br/>								(jdeStrlen(szTaxID)!=9) )<br/>							/* End Modification SAR 8819862 */<br/>							{<br/>								/*Divide by the modulus (operator)*/	<br/>								fDiv=div(iCalc,iModulus2);	<br/>								<br/>								/*calculate the remainder of the division*/<br/>								iRem=(int) fDiv.rem;<br/>								<br/>								/*For  Pernambuco if the check digit calculated is 10 then then<br/>								the check digit is equal to 0, otherwise the check digit is <br/>								equal to 1 which is the same as the right most character<br/>								of the check digit. Modulus 10 will get the right most character*/ <br/>								iCheckDigit2 = (iModulus-iRem);<br/>								iCheckDigit2 = iRem%10;<br/>								<br/>							}<br/>							else<br/>							{<br/>								<br/>								/*Divide by the modulus (operator)*/	<br/>								fDiv=div(iCalc,iModulus2);	<br/>								<br/>								/*calculate the remainder of the division*/<br/>								iRem=(int) fDiv.rem;<br/>								<br/>								/*if the modulus operator is equal to 11 and the remainder is <br/>								equal to 0 or 1 then the check digit is equal to 0*/<br/>								if ((iModulus2 == 11) && ((iRem == 0) || (iRem == 1)))<br/>								{<br/>									iCheckDigit2 = 0;<br/>								}<br/>								else<br/>								/*else if the modulus is equal to 10 and the remainder is<br/>								equal to 0 then the check digit is equal to 0*/<br/>								if ((iModulus2 == 10) && (iRem == 0))<br/>								{<br/>									iCheckDigit2 = 0;<br/>								}<br/>								else<br/>								{<br/>								/*Use the standard check digit calculation which is to subtract <br/>									the modulus (remainder) from the modulus (operator)*/<br/>									iCheckDigit2 = (iModulus2-iRem);<br/>								}<br/>								<br/>								<br/>								/*If the check digit calculated is not equal to the <br/>								check digit passed in then set an error flag to be read by<br/>								the main program where a hard error will set*/<br/>								if (iCheckDigit2 !=  ((int) szTaxID[iTaxIdLength+2] -_J('0')))<br/>								{	<br/>									bError = (BOOL) TRUE;<br/>									lpDSData-&gtcErrorFlag = 1;<br/>								}<br/>							}<br/>						}<br/>}		<br/><br/>return idReturnValue;<br/><br/>}<br/><br/></pre></div></div></body></html>