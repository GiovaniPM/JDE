<!DOCTYPE html><html lang = "en"><head><meta charset = "utf-8"><meta name = "viewport" content = "width=device-width, initial-scale=1"><title>JDE Object Browser HTML Extract</title>
<style type='text/css'>body,th{font-family: Courier New, Courier, mono;font-size: 12px; width:auto}
.section{font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width: 100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.objectheader {font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width:auto;background-color: #FFFFCC;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.details{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px;box-sizing: border-box }
.er {background-color: #FFFFFF;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal; border: thin solid #CCCCCC; width:auto; padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.dstrmembers {background-color: #FFFDDD;font-family: Courier New, Courier, mono;font-size: 12px;border: thin groove #CC9966;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.disabled {font-family: Courier New, Courier, mono;font-size: 12px;	font-style: italic; color:#CC9933}
.parameters {font-family: Courier New, Courier, mono;font-size: 12px; color:#3333FF}
.comment {font-family: Courier New, Courier, mono;font-size: 12px;	color: #339933}
.subtable {font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;width:100%}
.lineno {color:#6E6E6E;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.iokey {color:#FF6905;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.logicline {color:#000000;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.versionoverride {background-color: #FFCC99;}
.overrideflags{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:auto;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; background-color: #FFCC99; box-sizing: border-box }
.bsfnprops {font-family: Courier New, Courier, mono;font-size: 12px; color:#E01B4C}
.searchresult {font-family: Courier New, Courier, mono;font-size: 12px; font-weight: bold; background-color:#8BF3A0}
.expand {font-family: Courier New, Courier, mono;font-size: 11px; font-weight: bold; cursor:pointer; border: 1px solid gray; position: relative; left: -3px; display:inline; line-height:8px;}
.expand2 { display:inline; cursor:pointer; font-size: 9px; border: 1px solid gray; position: relative; left: -3px;}
</style>
<script type='text/javascript'>function load(){location.href = '#result';}</script>
<script language='JavaScript' type='text/javascript'>function ExpandCollapse(ElementId){ var ClickedElement = document.getElementById(ElementId); var SectionName = ElementId + ':hide'; var Section = document.getElementById(SectionName); if (ClickedElement.innerHTML == '-') { 	 ClickedElement.innerHTML = '+';	Section.style.display = 'none'; }  else  { 		ClickedElement.innerHTML = '-'; 	Section.style.display = 'inline';}} </script>
<base target = "_parent"></head><body onload='load()'>
<div class ='objectheader'>Business Function: B5576MD5 - Criptografia MD5<BR>Function Type: C</div><div class='section'>EVENTS<div class='objectheader'>C Function: Criptografia MD5 - [MD5criptography]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D5576B03 - Data Structure used to write the Magnetic Files (5000b).    </B><BR>BF szNameFlatFile [NFLF]<BR>BF mnRecordSize [ITM]<BR>BF szText [VAR1]<BR></div><pre><div class='dstrmembers'><B>Header File: b5576md5.h</B><BR></div>/*****************************************************************************<br/> * DS Template Type Definitions<br/> ****************************************************************************/<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Data Structure used to create/write the Magnetic Files.<br/> *    Template ID:   D5576B03<br/> *    Generated:     Fri Nov 05 10:56:49 1999<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the Everest Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D5576B03<br/>#define DATASTRUCTURE_D5576B03<br/><br/>typedef struct tagDSD5576B03<br/>{<br/>  JCHAR              szNameFlatFile[251];                 <br/>  MATH_NUMERIC      mnRecordSize;                        <br/>  JCHAR              szText[1501];             <br/>} DSD5576B03, *LPDSD5576B03;<br/><br/>#define IDERRszNameFlatFile_1                     1L<br/>#define IDERRmnRecordSize_2                       2L<br/>#define IDERRszText_3                             3L<br/><br/>#endif<br/><br/>#ifndef md5_INCLUDED<br/>#  define md5_INCLUDED<br/><br/>typedef BYTE md5_byte_t; /* 8-bit byte */<br/>typedef unsigned int md5_word_t; /* 32-bit word */<br/><br/>/* Define the state of the MD5 Algorithm. */<br/>typedef struct md5_state_s {<br/>    md5_word_t count[2];	/* message length in bits, lsw first */<br/>    md5_word_t abcd[4];		/* digest buffer */<br/>    md5_byte_t buf[64];		/* accumulate block */<br/>} md5_state_t;<br/><br/>#ifdef __cplusplus<br/>extern "C" <br/>{<br/>#endif<br/><br/>/* Initialize the algorithm. */<br/>void md5_init(md5_state_t *pms);<br/><br/>/* Append a string to the message. */<br/>void md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes);<br/><br/>/* Finish the message and return the digest. */<br/>void md5_finish(md5_state_t *pms, md5_byte_t digest[16]);<br/><br/>#ifdef __cplusplus<br/>}  /* end extern "C" */<br/>#endif<br/><br/>#endif /* md5_INCLUDED */<br/><br/>/*****************************************************************************<br/> * Source Preprocessor Definitions<br/> ****************************************************************************/<br/>#if defined (JDEBFRTN)<br/>	#undef JDEBFRTN<br/>#endif<br/><br/>#if defined (WIN32)<br/>	#if defined (WIN32)<br/>		#define JDEBFRTN(r) __declspec(dllexport) r<br/>	#else<br/>		#define JDEBFRTN(r) __declspec(dllimport) r<br/>	#endif<br/>#else<br/>	#define JDEBFRTN(r) r<br/>#endif<br/><br/>/*****************************************************************************<br/> * Business Function Prototypes<br/> ****************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI MD5criptography (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD5576B03 lpDS);<br/></pre><BR/><pre><div class='dstrmembers'><B>Source File: b5576md5.c</B><BR></div>#include &ltjde.h&gt<br/> <br/>#include "b5576md5.h"<br/>#include &ltstring.h&gt<br/> <br/> <br/>#undef BYTE_ORDER /* 1 = big-endian, -1 = little-endian, 0 = unknown */<br/>#ifdef ARCH_IS_BIG_ENDIAN<br/>#  define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1)<br/>#else<br/>#  define BYTE_ORDER 0<br/>#endif<br/> <br/>#define T_MASK_MD5 ((md5_word_t)~0)<br/>#define T1 /* 0xd76aa478 */ (T_MASK_MD5 ^ 0x28955b87)<br/>#define T2 /* 0xe8c7b756 */ (T_MASK_MD5 ^ 0x173848a9)<br/>#define T3    0x242070db<br/>#define T4 /* 0xc1bdceee */ (T_MASK_MD5 ^ 0x3e423111)<br/>#define T5 /* 0xf57c0faf */ (T_MASK_MD5 ^ 0x0a83f050)<br/>#define T6    0x4787c62a<br/>#define T7 /* 0xa8304613 */ (T_MASK_MD5 ^ 0x57cfb9ec)<br/>#define T8 /* 0xfd469501 */ (T_MASK_MD5 ^ 0x02b96afe)<br/>#define T9    0x698098d8<br/>#define T10 /* 0x8b44f7af */ (T_MASK_MD5 ^ 0x74bb0850)<br/>#define T11 /* 0xffff5bb1 */ (T_MASK_MD5 ^ 0x0000a44e)<br/>#define T12 /* 0x895cd7be */ (T_MASK_MD5 ^ 0x76a32841)<br/>#define T13    0x6b901122<br/>#define T14 /* 0xfd987193 */ (T_MASK_MD5 ^ 0x02678e6c)<br/>#define T15 /* 0xa679438e */ (T_MASK_MD5 ^ 0x5986bc71)<br/>#define T16    0x49b40821<br/>#define T17 /* 0xf61e2562 */ (T_MASK_MD5 ^ 0x09e1da9d)<br/>#define T18 /* 0xc040b340 */ (T_MASK_MD5 ^ 0x3fbf4cbf)<br/>#define T19    0x265e5a51<br/>#define T20 /* 0xe9b6c7aa */ (T_MASK_MD5 ^ 0x16493855)<br/>#define T21 /* 0xd62f105d */ (T_MASK_MD5 ^ 0x29d0efa2)<br/>#define T22    0x02441453<br/>#define T23 /* 0xd8a1e681 */ (T_MASK_MD5 ^ 0x275e197e)<br/>#define T24 /* 0xe7d3fbc8 */ (T_MASK_MD5 ^ 0x182c0437)<br/>#define T25    0x21e1cde6<br/>#define T26 /* 0xc33707d6 */ (T_MASK_MD5 ^ 0x3cc8f829)<br/>#define T27 /* 0xf4d50d87 */ (T_MASK_MD5 ^ 0x0b2af278)<br/>#define T28    0x455a14ed<br/>#define T29 /* 0xa9e3e905 */ (T_MASK_MD5 ^ 0x561c16fa)<br/>#define T30 /* 0xfcefa3f8 */ (T_MASK_MD5 ^ 0x03105c07)<br/>#define T31    0x676f02d9<br/>#define T32 /* 0x8d2a4c8a */ (T_MASK_MD5 ^ 0x72d5b375)<br/>#define T33 /* 0xfffa3942 */ (T_MASK_MD5 ^ 0x0005c6bd)<br/>#define T34 /* 0x8771f681 */ (T_MASK_MD5 ^ 0x788e097e)<br/>#define T35    0x6d9d6122<br/>#define T36 /* 0xfde5380c */ (T_MASK_MD5 ^ 0x021ac7f3)<br/>#define T37 /* 0xa4beea44 */ (T_MASK_MD5 ^ 0x5b4115bb)<br/>#define T38    0x4bdecfa9<br/>#define T39 /* 0xf6bb4b60 */ (T_MASK_MD5 ^ 0x0944b49f)<br/>#define T40 /* 0xbebfbc70 */ (T_MASK_MD5 ^ 0x4140438f)<br/>#define T41    0x289b7ec6<br/>#define T42 /* 0xeaa127fa */ (T_MASK_MD5 ^ 0x155ed805)<br/>#define T43 /* 0xd4ef3085 */ (T_MASK_MD5 ^ 0x2b10cf7a)<br/>#define T44    0x04881d05<br/>#define T45 /* 0xd9d4d039 */ (T_MASK_MD5 ^ 0x262b2fc6)<br/>#define T46 /* 0xe6db99e5 */ (T_MASK_MD5 ^ 0x1924661a)<br/>#define T47    0x1fa27cf8<br/>#define T48 /* 0xc4ac5665 */ (T_MASK_MD5 ^ 0x3b53a99a)<br/>#define T49 /* 0xf4292244 */ (T_MASK_MD5 ^ 0x0bd6ddbb)<br/>#define T50    0x432aff97<br/>#define T51 /* 0xab9423a7 */ (T_MASK_MD5 ^ 0x546bdc58)<br/>#define T52 /* 0xfc93a039 */ (T_MASK_MD5 ^ 0x036c5fc6)<br/>#define T53    0x655b59c3<br/>#define T54 /* 0x8f0ccc92 */ (T_MASK_MD5 ^ 0x70f3336d)<br/>#define T55 /* 0xffeff47d */ (T_MASK_MD5 ^ 0x00100b82)<br/>#define T56 /* 0x85845dd1 */ (T_MASK_MD5 ^ 0x7a7ba22e)<br/>#define T57    0x6fa87e4f<br/>#define T58 /* 0xfe2ce6e0 */ (T_MASK_MD5 ^ 0x01d3191f)<br/>#define T59 /* 0xa3014314 */ (T_MASK_MD5 ^ 0x5cfebceb)<br/>#define T60    0x4e0811a1<br/>#define T61 /* 0xf7537e82 */ (T_MASK_MD5 ^ 0x08ac817d)<br/>#define T62 /* 0xbd3af235 */ (T_MASK_MD5 ^ 0x42c50dca)<br/>#define T63    0x2ad7d2bb<br/>#define T64 /* 0xeb86d391 */ (T_MASK_MD5 ^ 0x14792c6e)<br/> <br/>JDEBFRTN (ID) JDEBFWINAPI MD5criptography (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD5576B03 lpDS) <br/>{<br/>      ZCHAR szStringEntrada[1501] = {0};<br/>      ZCHAR szStringSaida[1501] = {0};<br/> <br/>      md5_state_t state;<br/>      md5_byte_t digest[16];<br/>      ZCHAR hex_output[16*2 + 1];<br/>     <br/>      ZCHAR hex_aux0[ 3 + 1] = " | ";<br/>      ZCHAR hex_aux1[32 + 1] = "";<br/>      ZCHAR hex_aux2[32 + 1] = "";<br/>      ZCHAR hex_aux3[39 + 1] = "";<br/>      ZCHAR hex_aux4[39 + 1] = "";<br/>      int i =0;<br/>      int j =0;<br/>      int cont=0;<br/>     <br/>      int di;<br/>      //di = (int) jdeAtoi (lpDS-&gtmnRecordSize.String );<br/>      MathNumericToInt(&lpDS-&gtmnRecordSize, &di);<br/>    jdeFromUnicode(szStringEntrada, lpDS-&gtszText, di, NULL);<br/> <br/>      md5_init  ( &state );<br/>      //md5_append( &state, (const md5_byte_t *)lpDS-&gtszText, di);<br/>      md5_append( &state, (const md5_byte_t *)szStringEntrada, di);<br/>      md5_finish( &state, digest );<br/> <br/>      for (di = 0; di &lt 16; ++di)<br/>          sprintf(hex_output + di * 2, "%02x", digest[di]);<br/> <br/>      //Aux1 = Uppercase<br/>      strncpy  ( hex_aux1, hex_output, 32 );<br/>      _strupr( hex_aux1 );<br/> <br/>      //Aux2 = Downcase (normal)<br/>      strncpy  (hex_aux2, hex_output, 32 );<br/> <br/>      //Aux3/4 = Formata com Ponto/Branco<br/>      while(i &lt 32)<br/>      {<br/>            cont++;<br/>            if(cont == 5)<br/>            {<br/>                  hex_aux3[j] = '.';<br/>                  hex_aux4[j] = ' ';<br/>                  j++;<br/>                  cont = 1;<br/>            }<br/>            hex_aux3[j] = hex_aux1[i];<br/>            hex_aux4[j] = hex_aux1[i];<br/>            j++;<br/>            i++;<br/>      }<br/> <br/>      //Initialize the output parameter with NULL.<br/>      memset( (void *) szStringSaida,'\0', 251 );<br/> <br/>      //Concatena as chaves FORMATADAS<br/>      //Uppercase<br/>      strncpy ( szStringSaida, hex_aux1, 32 );<br/>      strcat  ( szStringSaida, hex_aux0 );<br/> <br/>      //Downcase (normal)<br/>      strcat  ( szStringSaida, hex_aux2 );<br/>      strcat  ( szStringSaida, hex_aux0 );<br/> <br/>      //Com Ponto<br/>      strcat  ( szStringSaida, hex_aux3 );<br/>      strcat  ( szStringSaida, hex_aux0 );<br/> <br/>      //Com Branco<br/>      strcat  ( szStringSaida, hex_aux4 );<br/> <br/>      //----------------------------------<br/>      jdeToUnicode(lpDS-&gtszNameFlatFile, szStringSaida, DIM(lpDS-&gtszNameFlatFile), NULL);<br/>     <br/>      return (ER_SUCCESS);<br/>}<br/> <br/>static void<br/>md5_process(md5_state_t *pms, const md5_byte_t *data /*[64]*/)<br/>{<br/>    md5_word_t<br/>      a = pms-&gtabcd[0], b = pms-&gtabcd[1],<br/>      c = pms-&gtabcd[2], d = pms-&gtabcd[3];<br/>    md5_word_t t;<br/>#if BYTE_ORDER &gt 0<br/>    /* Define storage only for big-endian CPUs. */<br/>    md5_word_t X[16];<br/>#else<br/>    /* Define storage for little-endian or both types of CPUs. */<br/>    md5_word_t xbuf[16];<br/>    const md5_word_t *X;<br/>#endif<br/> <br/>    {<br/>#if BYTE_ORDER == 0<br/>      /*<br/>      * Determine dynamically whether this is a big-endian or<br/>      * little-endian machine, since we can use a more efficient<br/>      * algorithm on the latter.<br/>      */<br/>      static const int w = 1;<br/> <br/>      if (*((const md5_byte_t *)&w)) /* dynamic little-endian */<br/>#endif<br/>#if BYTE_ORDER &lt= 0          /* little-endian */<br/>      {<br/>          /*<br/>           * On little-endian machines, we can process properly aligned<br/>           * data without copying it.<br/>           */<br/>          if (!((data - (const md5_byte_t *)0) & 3)) {<br/>            /* data are properly aligned */<br/>            X = (const md5_word_t *)data;<br/>          } else {<br/>            /* not aligned */<br/>            memcpy(xbuf, data, 64);<br/>            X = xbuf;<br/>          }<br/>      }<br/>#endif<br/>#if BYTE_ORDER == 0<br/>      else              /* dynamic big-endian */<br/>#endif<br/>#if BYTE_ORDER &gt= 0          /* big-endian */<br/>      {<br/>          /*<br/>           * On big-endian machines, we must arrange the bytes in the<br/>           * right order.<br/>           */<br/>          const md5_byte_t *xp = data;<br/>          int i;<br/> <br/>#  if BYTE_ORDER == 0<br/>          X = xbuf;           /* (dynamic only) */<br/>#  else<br/>#    define xbuf X           /* (static only) */<br/>#  endif<br/>          for (i = 0; i &lt 16; ++i, xp += 4)<br/>            xbuf[i] = xp[0] + (xp[1] &lt&lt 8) + (xp[2] &lt&lt 16) + (xp[3] &lt&lt 24);<br/>      }<br/>#endif<br/>    }<br/> <br/>#define ROTATE_LEFT(x, n) (((x) &lt&lt (n)) | ((x) &gt&gt (32 - (n))))<br/> <br/>    /* Round 1. */<br/>    /* Let [abcd k s i] denote the operation<br/>       a = b + ((a + F(b,c,d) + X[k] + T[i]) &lt&lt&lt s). */<br/>#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))<br/>#define SET(a, b, c, d, k, s, Ti)\<br/>  t = a + F(b,c,d) + X[k] + Ti;\<br/>  a = ROTATE_LEFT(t, s) + b<br/>    /* Do the following 16 operations. */<br/>    SET(a, b, c, d,  0,  7,  T1);<br/>    SET(d, a, b, c,  1, 12,  T2);<br/>    SET(c, d, a, b,  2, 17,  T3);<br/>    SET(b, c, d, a,  3, 22,  T4);<br/>    SET(a, b, c, d,  4,  7,  T5);<br/>    SET(d, a, b, c,  5, 12,  T6);<br/>    SET(c, d, a, b,  6, 17,  T7);<br/>    SET(b, c, d, a,  7, 22,  T8);<br/>    SET(a, b, c, d,  8,  7,  T9);<br/>    SET(d, a, b, c,  9, 12, T10);<br/>    SET(c, d, a, b, 10, 17, T11);<br/>    SET(b, c, d, a, 11, 22, T12);<br/>    SET(a, b, c, d, 12,  7, T13);<br/>    SET(d, a, b, c, 13, 12, T14);<br/>    SET(c, d, a, b, 14, 17, T15);<br/>    SET(b, c, d, a, 15, 22, T16);<br/>#undef SET<br/> <br/>     /* Round 2. */<br/>     /* Let [abcd k s i] denote the operation<br/>          a = b + ((a + G(b,c,d) + X[k] + T[i]) &lt&lt&lt s). */<br/>#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))<br/>#define SET(a, b, c, d, k, s, Ti)\<br/>  t = a + G(b,c,d) + X[k] + Ti;\<br/>  a = ROTATE_LEFT(t, s) + b<br/>     /* Do the following 16 operations. */<br/>    SET(a, b, c, d,  1,  5, T17);<br/>    SET(d, a, b, c,  6,  9, T18);<br/>    SET(c, d, a, b, 11, 14, T19);<br/>    SET(b, c, d, a,  0, 20, T20);<br/>    SET(a, b, c, d,  5,  5, T21);<br/>    SET(d, a, b, c, 10,  9, T22);<br/>    SET(c, d, a, b, 15, 14, T23);<br/>    SET(b, c, d, a,  4, 20, T24);<br/>    SET(a, b, c, d,  9,  5, T25);<br/>    SET(d, a, b, c, 14,  9, T26);<br/>    SET(c, d, a, b,  3, 14, T27);<br/>    SET(b, c, d, a,  8, 20, T28);<br/>    SET(a, b, c, d, 13,  5, T29);<br/>    SET(d, a, b, c,  2,  9, T30);<br/>    SET(c, d, a, b,  7, 14, T31);<br/>    SET(b, c, d, a, 12, 20, T32);<br/>#undef SET<br/> <br/>     /* Round 3. */<br/>     /* Let [abcd k s t] denote the operation<br/>          a = b + ((a + H(b,c,d) + X[k] + T[i]) &lt&lt&lt s). */<br/>#define H(x, y, z) ((x) ^ (y) ^ (z))<br/>#define SET(a, b, c, d, k, s, Ti)\<br/>  t = a + H(b,c,d) + X[k] + Ti;\<br/>  a = ROTATE_LEFT(t, s) + b<br/>     /* Do the following 16 operations. */<br/>    SET(a, b, c, d,  5,  4, T33);<br/>    SET(d, a, b, c,  8, 11, T34);<br/>    SET(c, d, a, b, 11, 16, T35);<br/>    SET(b, c, d, a, 14, 23, T36);<br/>    SET(a, b, c, d,  1,  4, T37);<br/>    SET(d, a, b, c,  4, 11, T38);<br/>    SET(c, d, a, b,  7, 16, T39);<br/>    SET(b, c, d, a, 10, 23, T40);<br/>    SET(a, b, c, d, 13,  4, T41);<br/>    SET(d, a, b, c,  0, 11, T42);<br/>    SET(c, d, a, b,  3, 16, T43);<br/>    SET(b, c, d, a,  6, 23, T44);<br/>    SET(a, b, c, d,  9,  4, T45);<br/>    SET(d, a, b, c, 12, 11, T46);<br/>    SET(c, d, a, b, 15, 16, T47);<br/>    SET(b, c, d, a,  2, 23, T48);<br/>#undef SET<br/> <br/>     /* Round 4. */<br/>     /* Let [abcd k s t] denote the operation<br/>          a = b + ((a + I(b,c,d) + X[k] + T[i]) &lt&lt&lt s). */<br/>#define I(x, y, z) ((y) ^ ((x) | ~(z)))<br/>#define SET(a, b, c, d, k, s, Ti)\<br/>  t = a + I(b,c,d) + X[k] + Ti;\<br/>  a = ROTATE_LEFT(t, s) + b<br/>     /* Do the following 16 operations. */<br/>    SET(a, b, c, d,  0,  6, T49);<br/>    SET(d, a, b, c,  7, 10, T50);<br/>    SET(c, d, a, b, 14, 15, T51);<br/>    SET(b, c, d, a,  5, 21, T52);<br/>    SET(a, b, c, d, 12,  6, T53);<br/>    SET(d, a, b, c,  3, 10, T54);<br/>    SET(c, d, a, b, 10, 15, T55);<br/>    SET(b, c, d, a,  1, 21, T56);<br/>    SET(a, b, c, d,  8,  6, T57);<br/>    SET(d, a, b, c, 15, 10, T58);<br/>    SET(c, d, a, b,  6, 15, T59);<br/>    SET(b, c, d, a, 13, 21, T60);<br/>    SET(a, b, c, d,  4,  6, T61);<br/>    SET(d, a, b, c, 11, 10, T62);<br/>    SET(c, d, a, b,  2, 15, T63);<br/>    SET(b, c, d, a,  9, 21, T64);<br/>#undef SET<br/> <br/>     /* Then perform the following additions. (That is increment each<br/>        of the four registers by the value it had before this block<br/>        was started.) */<br/>    pms-&gtabcd[0] += a;<br/>    pms-&gtabcd[1] += b;<br/>    pms-&gtabcd[2] += c;<br/>    pms-&gtabcd[3] += d;<br/>}<br/> <br/>void<br/>md5_init(md5_state_t *pms)<br/>{<br/>    pms-&gtcount[0] = pms-&gtcount[1] = 0;<br/>    pms-&gtabcd[0] = 0x67452301;<br/>    pms-&gtabcd[1] = /*0xefcdab89*/ T_MASK_MD5 ^ 0x10325476;<br/>    pms-&gtabcd[2] = /*0x98badcfe*/ T_MASK_MD5 ^ 0x67452301;<br/>    pms-&gtabcd[3] = 0x10325476;<br/>}<br/> <br/>void<br/>md5_append(md5_state_t *pms, const md5_byte_t *data, int nbytes)<br/>{<br/>    const md5_byte_t *p = data;<br/>    int left = nbytes;<br/>    int offset = (pms-&gtcount[0] &gt&gt 3) & 63;<br/>    md5_word_t nbits = (md5_word_t)(nbytes &lt&lt 3);<br/> <br/>    if (nbytes &lt= 0)<br/>      return;<br/> <br/>    /* Update the message length. */<br/>    pms-&gtcount[1] += nbytes &gt&gt 29;<br/>    pms-&gtcount[0] += nbits;<br/>    if (pms-&gtcount[0] &lt nbits)<br/>      pms-&gtcount[1]++;<br/> <br/>    /* Process an initial partial block. */<br/>    if (offset) {<br/>      int copy = (offset + nbytes &gt 64 ? 64 - offset : nbytes);<br/> <br/>      memcpy(pms-&gtbuf + offset, p, copy);<br/>      if (offset + copy &lt 64)<br/>          return;<br/>      p += copy;<br/>      left -= copy;<br/>      md5_process(pms, pms-&gtbuf);<br/>    }<br/> <br/>    /* Process full blocks. */<br/>    for (; left &gt= 64; p += 64, left -= 64)<br/>      md5_process(pms, p);<br/> <br/>    /* Process a final partial block. */<br/>    if (left)<br/>      memcpy(pms-&gtbuf, p, left);<br/>}<br/> <br/>void<br/>md5_finish(md5_state_t *pms, md5_byte_t digest[16])<br/>{<br/>    static const md5_byte_t pad[64] = {<br/>      0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,<br/>      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0<br/>    };<br/>    md5_byte_t data[8];<br/>    int i;<br/> <br/>    /* Save the length before padding. */<br/>    for (i = 0; i &lt 8; ++i)<br/>      data[i] = (md5_byte_t)(pms-&gtcount[i &gt&gt 2] &gt&gt ((i & 3) &lt&lt 3));<br/>    /* Pad to 56 bytes mod 64. */<br/>    md5_append(pms, pad, ((55 - (pms-&gtcount[0] &gt&gt 3)) & 63) + 1);<br/>    /* Append the length. */<br/>    md5_append(pms, data, 8);<br/>    for (i = 0; i &lt 16; ++i)<br/>      digest[i] = (md5_byte_t)(pms-&gtabcd[i &gt&gt 2] &gt&gt ((i & 3) &lt&lt 3));<br/>}<br/></pre></div></div></body></html>