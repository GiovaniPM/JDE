<!DOCTYPE html><html lang = "en"><head><meta charset = "utf-8"><meta name = "viewport" content = "width=device-width, initial-scale=1"><title>JDE Object Browser HTML Extract</title>
<style type='text/css'>body,th{font-family: Courier New, Courier, mono;font-size: 12px; width:auto}
.section{font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width: 100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.objectheader {font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width:auto;background-color: #FFFFCC;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.details{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px;box-sizing: border-box }
.er {background-color: #FFFFFF;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal; border: thin solid #CCCCCC; width:auto; padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.dstrmembers {background-color: #FFFDDD;font-family: Courier New, Courier, mono;font-size: 12px;border: thin groove #CC9966;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.disabled {font-family: Courier New, Courier, mono;font-size: 12px;	font-style: italic; color:#CC9933}
.parameters {font-family: Courier New, Courier, mono;font-size: 12px; color:#3333FF}
.comment {font-family: Courier New, Courier, mono;font-size: 12px;	color: #339933}
.subtable {font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;width:100%}
.lineno {color:#6E6E6E;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.iokey {color:#FF6905;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.logicline {color:#000000;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.versionoverride {background-color: #FFCC99;}
.overrideflags{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:auto;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; background-color: #FFCC99; box-sizing: border-box }
.bsfnprops {font-family: Courier New, Courier, mono;font-size: 12px; color:#E01B4C}
.searchresult {font-family: Courier New, Courier, mono;font-size: 12px; font-weight: bold; background-color:#8BF3A0}
.expand {font-family: Courier New, Courier, mono;font-size: 11px; font-weight: bold; cursor:pointer; border: 1px solid gray; position: relative; left: -3px; display:inline; line-height:8px;}
.expand2 { display:inline; cursor:pointer; font-size: 9px; border: 1px solid gray; position: relative; left: -3px;}
</style>
<script type='text/javascript'>function load(){location.href = '#result';}</script>
<script language='JavaScript' type='text/javascript'>function ExpandCollapse(ElementId){ var ClickedElement = document.getElementById(ElementId); var SectionName = ElementId + ':hide'; var Section = document.getElementById(SectionName); if (ClickedElement.innerHTML == '-') { 	 ClickedElement.innerHTML = '+';	Section.style.display = 'none'; }  else  { 		ClickedElement.innerHTML = '-'; 	Section.style.display = 'inline';}} </script>
<base target = "_parent"></head><body onload='load()'>
<div class ='objectheader'>Business Function: B57EVAL - Executa Expressão<BR>Function Type: C</div><div class='section'>EVENTS<div class='objectheader'>C Function: Executa Expressão - [CarregaExpressoes]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57EVALA - Estrutura de Dados da Função B57EVAL                        </B><BR>BF idExpressao [GENLNG]<BR>BF szNomeExpressao [AA12]<BR>BF cRetorno [ERRC]<BR>BF szProcesso [PROCESS]<BR></div><pre><div class='dstrmembers'><B>Header File: b57eval.h</B><BR></div><br/>/*****************************************************************************<br/> *    Header File:  B57EVAL.h<br/> *<br/> *    Description:  Executa Expressão Header File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 25/11/10                Unknown  - Created  <br/> *<br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source <br/> * Company.  All rights reserved.  The methods and techniques described <br/> * herein are considered trade secrets and/or confidential.  Reproduction<br/> * or distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/><br/>#ifndef __B57EVAL_H<br/>#define __B57EVAL_H<br/><br/>/*****************************************************************************<br/> * Table Header Inclusions<br/> ****************************************************************************/<br/>#include &ltf57expre.h&gt<br/>#include &ltf57expdt.h&gt<br/>#include &ltf57expcr.h&gt<br/>#include &ltf57expva.h&gt<br/>/*****************************************************************************<br/> * External Business Function Header Inclusions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * Global Definitions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * Structure Definitions<br/> ****************************************************************************/<br/>typedef struct tagDDINFO { <br/>	<br/>	LPGLOBALCOL lpGlobalCol; <br/>	LPVOID lpValue; <br/>	PJSTR lpScreenValue; <br/>	WORD wStatus; <br/>	DWORD dwOverrideFlag; <br/>	LPDDEDIT lpEditRules; <br/>	LPDDFORMAT lpFormatRules; <br/>	<br/>} DSDDINFO;<br/>//<br/>typedef struct NodoPilha_t {<br/>	void   *Data;<br/>	JCHAR   sztipodata[11];<br/>	struct NodoPilha_t *Prox;<br/>} NodoPilha;<br/>//<br/>typedef struct Pilha{<br/>	 NodoPilha *Cabeca;<br/>	 NodoPilha *Nodos;<br/>} Pilha;<br/>//<br/>typedef struct NodoLista_t<br/>{<br/>	JCHAR NomeVariavel[13];<br/>	void *Valor;<br/>	JCHAR NomeTabela[8];<br/>	JCHAR NomeCampo[11];<br/>} NodoVariavel, *ListaVariaveis;<br/>//<br/>typedef struct NodoArvore_t<br/>{<br/>	void *data;<br/>	JCHAR  sztipodata[11];<br/>	struct NodoArvore_t *filho_esquerda;<br/>	struct NodoArvore_t *filho_direita;<br/>} Nodo_Arvore;<br/>//<br/>typedef struct ArvoreBinaria_t<br/>{<br/>	JCHAR   Nome[30];<br/>	int    NumExpressoes;<br/>	ListaVariaveis lv;<br/>	struct NodoArvore_t *Arvores;<br/>} Arvore_Binaria;<br/>//<br/>/*****************************************************************************<br/> * DS Template Type Definitions<br/> ****************************************************************************/<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Estrutura de Dados da Função B57EVAL<br/> *    Template ID:   D57EVALA<br/> *    Generated:     Thu Dec 02 11:04:14 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57EVALA<br/>#define DATASTRUCTURE_D57EVALA<br/><br/>typedef struct tagDSD57EVALA<br/>{<br/>  ID                idExpressao;                         <br/>  JCHAR              szNomeExpressao[13];                 <br/>  JCHAR              cRetorno;                            <br/>  JCHAR              szProcesso[31];                      <br/>} DSD57EVALA, *LPDSD57EVALA;<br/><br/>#define IDERRidExpressao_1                        1L<br/>#define IDERRszNomeExpressao_2                    2L<br/>#define IDERRcRetorno_4                           4L<br/>#define IDERRszProcesso_5                         5L<br/><br/>#endif<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Estrutura de Dados da Função B57EVAL<br/> *    Template ID:   D57EVALC<br/> *    Generated:     Fri Nov 26 17:50:21 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57EVALC<br/>#define DATASTRUCTURE_D57EVALC<br/><br/>typedef struct tagDSD57EVALC<br/>{<br/>  ID                idExpressoes;                        <br/>  JCHAR              cRetorno;                            <br/>} DSD57EVALC, *LPDSD57EVALC;<br/><br/>#define IDERRidExpressoes_1                       1L<br/>#define IDERRcRetorno_2                           2L<br/><br/>#endif<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Estrutura de Dados da Função B57EVAL<br/> *    Template ID:   D57EVALB<br/> *    Generated:     Fri Nov 26 17:50:49 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/>#ifndef DATASTRUCTURE_D57EVALB<br/>#define DATASTRUCTURE_D57EVALB<br/><br/>typedef struct tagDSD57EVALB<br/>{<br/>  ID                idExpressoes;                        <br/>  JCHAR              szNomeExpressao[13];                 <br/>  JCHAR              cRetorno;                            <br/>} DSD57EVALB, *LPDSD57EVALB;<br/><br/>#define IDERRidExpressoes_1                       1L<br/>#define IDERRszNomeExpressao_2                    2L<br/>#define IDERRcRetorno_3                           3L<br/><br/>#endif<br/><br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Estrutura de Dados da Função B57EVAL<br/> *    Template ID:   D57EVALD<br/> *    Generated:     Wed Nov 16 14:03:47 2011<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57EVALD<br/>#define DATASTRUCTURE_D57EVALD<br/><br/>typedef struct tagDSD57EVALD<br/>{<br/>  JCHAR              szVariavel[13];                      <br/>  ID                idExpressao;                         <br/>  JCHAR              szDataItem[12];                      <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szValorString[41];                   <br/>  MATH_NUMERIC      mnValorNumerico;                     <br/>  JDEDATE           jdValorData;                         <br/>  JCHAR              cValorChar;                          <br/>  int               nValorInteiro;                       <br/>} DSD57EVALD, *LPDSD57EVALD;<br/><br/>#define IDERRszVariavel_1                         1L<br/>#define IDERRidExpressao_2                        2L<br/>#define IDERRszDataItem_3                         3L<br/>#define IDERRcCodigoErro_5                        5L<br/>#define IDERRszValorString_6                      6L<br/>#define IDERRmnValorNumerico_7                    7L<br/>#define IDERRjdValorData_8                        8L<br/>#define IDERRcValorChar_9                         9L<br/>#define IDERRnValorInteiro_10                     10L<br/><br/>#endif<br/><br/><br/>/*****************************************************************************<br/> * Source Preprocessor Definitions<br/> ****************************************************************************/<br/>#if defined (JDEBFRTN)<br/>	#undef JDEBFRTN<br/>#endif<br/><br/>#if defined (WIN32)<br/>	#if defined (WIN32)<br/>		#define JDEBFRTN(r) __declspec(dllexport) r<br/>	#else<br/>		#define JDEBFRTN(r) __declspec(dllimport) r<br/>	#endif<br/>#else<br/>	#define JDEBFRTN(r) r<br/>#endif<br/><br/>/*****************************************************************************<br/> * Business Function Prototypes<br/> ****************************************************************************/<br/>JDEBFRTN (ID) JDEBFWINAPI CarregaExpressoes                (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALA lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI DescarregaExpressoes             (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALC lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI ExecutaExpressao                 (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALB lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI SetaVariavel                     (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALD lpDS);<br/><br/>/*****************************************************************************<br/> * Internal Function Prototypes<br/> ****************************************************************************/<br/>//funções pilha<br/>BOOL I57EVAL_Empilha(JCHAR *szItemDados, struct Pilha *pilha, void *Data);<br/>void *I57EVAL_DesEmpilha(struct Pilha *pilha);<br/>void I57EVAL_IniciaPilha(struct Pilha *pilha);<br/>//funções <br/>BOOL I57EVAL_Precedencia(JCHAR *OperadorA, JCHAR *OperadorB);<br/>int  I57EVAL_CopiaValor(JCHAR *szItemDados, void **ValorDestino, void *ValorOrigem);<br/>int  I57EVAL_ComparaValor(JCHAR *szItemDados, void *Valor1, void *Valor2);<br/>JCHAR *I57EVAL_TipoDado(HREQUEST *hF57EXPCR, JCHAR *Chave);<br/>void I57EVAL_ParseValor(JCHAR *szItemDados, JCHAR *Valor, void **ValorRetorno);<br/>BOOL I57EVAL_Operador(JCHAR *Operador);<br/>//funções arvore <br/>Arvore_Binaria *I57EVAL_CriarArvore(JCHAR *Nome);<br/>Nodo_Arvore *I57EVAL_CriarNovoNodo(JCHAR *szItemDados, void *Data);<br/>void I57EVAL_ExecutaExpressao(Nodo_Arvore *Raiz);<br/>//funcções string<br/>void I57EVAL_RemoveSurroundingBlanks(JCHAR * szString);<br/>void I57EVAL_strpadl(JCHAR *lpszString, const JCHAR *szPad, size_t nLen);<br/>void I57EVAL_strpadr(JCHAR *lpszString, const JCHAR *szPad, size_t nLen); <br/>//funções Operações<br/>void *I57EVAL_ExecutaOperador(JCHAR *Operador, Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>void *I57EVAL_Soma(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>void *I57EVAL_Subtracao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>void *I57EVAL_Divisao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>void *I57EVAL_Multiplicacao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_Igual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_Maior(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_Menor(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_MaiorIgual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_MenorIgual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>void *I57EVAL_Exponenciacao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_E(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_OU(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>BOOL I57EVAL_SE(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita);<br/>//<br/>void *I57EVAL_ValorVariavel(JCHAR *szNomeVariavel);<br/>//<br/>ID I57EVAL_CarregaVariaveis(HUSER hUser, JCHAR *szNomeProcesso, JCHAR *szNomeExpressao, ListaVariaveis *lv);<br/>ID I57EVAL_BuscaValorVariavelUBE(LPBHVRCOM lpBhvrCom, HUSER hUser, ListaVariaveis *lv);<br/>#endif    /* __B57EVAL_H */<br/><br/><br/><br/></pre><BR/><pre><div class='dstrmembers'><B>Source File: b57eval.c</B><BR></div>#include &ltjde.h&gt<br/><br/>#define b57eval_c<br/><br/><br/>/*****************************************************************************<br/> *    Source File:  b57eval<br/> *<br/> *    Description:  Executa Expressão Source File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 25/11/10                Unknown  - Created  <br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source Company.<br/> * All rights reserved.  The methods and techniques described herein are<br/> * considered trade secrets and/or confidential.  Reproduction or<br/> * distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/>/**************************************************************************<br/> * Notes:<br/> *<br/> **************************************************************************/<br/><br/>#include &ltb57eval.h&gt<br/><br/>/**************************************************************************<br/> *  Business Function:  CarregaExpressoes<br/> *<br/> *        Description:  Carrega Expressoes<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57EVALA        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI CarregaExpressoes (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALA lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>	HUSER       hUser              = (HUSER)NULL;<br/>	ID          idResultado        = JDEDB_PASSED;<br/>	HREQUEST    hF57EXPRE          = (HREQUEST)NULL; // Handle cabeçalho das expressões<br/>	HREQUEST    hF57EXPDT          = (HREQUEST)NULL; // Handle tabela de expressões<br/>	HREQUEST    hF57EXPCR          = (HREQUEST)NULL; // Handle tabela de tipo de dados<br/>	//<br/>	F57EXPRE		dsF57EXPRE;<br/>	KEY1_F57EXPRE   dsF57EXPREKey;<br/>	F57EXPDT		dsF57EXPDT;<br/>	KEY1_F57EXPDT   dsF57EXPDTKey;<br/>	KEY1_F57EXPCR   dsF57EXPCRKey;<br/>	//<br/>	SORTSTRUCT      dsSequencia[1] = {0};<br/>	//<br/>	Arvore_Binaria *ArvoreExp;<br/>	Nodo_Arvore    *NodoTemporario;<br/>	Pilha          PilhaOperandos;<br/>	Pilha          PilhaNo;<br/>	//<br/>	int    nTamanho;<br/>	JCHAR   szItemDados[11] = {0};<br/>	JCHAR   szPalavra[100];<br/>	void   *dados;<br/>	JCHAR   szCaracter[2];<br/>	int    i;<br/>	int    NumRecords = 0;  <br/>	int    NumRecord  = 0;<br/>	//<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>	if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57EVALA)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idResultado = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idResultado == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//<br/>	jdeNIDcpy(dsSequencia[0].Item.szDict, NID_SEQ);<br/>	jdeNIDcpy(dsSequencia[0].Item.szTable, NID_F57EXPDT);<br/>	dsSequencia[0].Item.idInstance = 0;<br/>	dsSequencia[0].nSort = JDEDB_SORT_ASC;<br/>	//Abre o cabeçalho das expressões<br/>	idResultado = JDB_OpenTable(hUser, _J("F57EXPRE"), 0, NULL, 0, NULL, &hF57EXPRE); <br/>	if (idResultado != JDEDB_PASSED) return ER_ERROR ;<br/>	//Abre o detalhe das expressões<br/>	idResultado = JDB_OpenTable(hUser, _J("F57EXPDT"), 0, NULL, 0, NULL, &hF57EXPDT); <br/>	if (idResultado != JDEDB_PASSED) return ER_ERROR ;<br/>	//Abre a tabela de tipos de dados<br/>	idResultado = JDB_OpenTable(hUser, _J("F57EXPCR"), 0, NULL, 0, NULL, &hF57EXPCR); <br/>    if (idResultado == JDEDB_PASSED) <br/>    {<br/> 		idResultado = JDB_ClearColBuffer(hF57EXPRE, &dsF57EXPRE); <br/>		//<br/>		jdeStrncpy (dsF57EXPREKey.epprocess,(const JCHAR *)(lpDS-&gtszProcesso), DIM(dsF57EXPREKey.epprocess));<br/>		//       <br/>		NumRecords = JDB_SelectKeyedGetCount(hF57EXPRE, ID_F57EXPRE_PK, (void *) &dsF57EXPREKey, (short) 1);<br/>		//<br/>		if (NumRecords == 0) return (ER_ERROR);<br/>		//<br/>		idResultado = JDB_SelectKeyed( hF57EXPRE, ID_F57EXPRE_PK, (void *) &dsF57EXPREKey, (short) 1);<br/>		//<br/>		if (idResultado == JDEDB_PASSED) <br/>		{<br/>			//cria a arvore de expressões<br/>			ArvoreExp = I57EVAL_CriarArvore(lpDS-&gtszProcesso);<br/>			//loop expressões - de acordo com processo<br/>			I57EVAL_IniciaPilha(&PilhaOperandos);<br/>			I57EVAL_IniciaPilha(&PilhaNo);<br/>			while (JDB_FetchMatchingKey(hF57EXPRE, (void *)&dsF57EXPREKey, (short)1, (void *)&dsF57EXPRE, (int)FALSE) == JDEDB_PASSED)<br/>			{<br/>				if (idResultado == JDEDB_PASSED) <br/>				{<br/>					//<br/>					NumRecord++;<br/>					//<br/>					JDB_SetSequencing(hF57EXPDT, dsSequencia, 1, JDEDB_SET_REPLACE);<br/>					//<br/>					JDB_ClearColBuffer(hF57EXPDT, &dsF57EXPDT); <br/>					//<br/>					jdeStrncpy (dsF57EXPDTKey.edprocess,(const JCHAR *)(dsF57EXPRE.epprocess), DIM(dsF57EXPDTKey.edprocess));	<br/>					jdeStrncpy (dsF57EXPDTKey.edaa12,(const JCHAR *)(dsF57EXPRE.epaa12), DIM(dsF57EXPDTKey.edaa12));				<br/>					//<br/>					I57EVAL_CarregaVariaveis(hUser, lpDS-&gtszProcesso, dsF57EXPRE.epaa12, &ArvoreExp-&gtlv);<br/>					//<br/>					idResultado = JDB_SelectKeyed( hF57EXPDT, ID_F57EXPDT_PK, (void *) &dsF57EXPDTKey, (short) 2);<br/>					//<br/>					while (JDB_FetchMatchingKey(hF57EXPDT, (void *)&dsF57EXPDTKey, (short)2, (void *)&dsF57EXPDT, (int)FALSE) == JDEDB_PASSED)<br/>					{<br/>						//						<br/>						jdeStrcpy(szItemDados, I57EVAL_TipoDado(hF57EXPCR, dsF57EXPDT.edobnd));<br/>						I57EVAL_RemoveSurroundingBlanks(szItemDados);<br/>						I57EVAL_RemoveSurroundingBlanks((JCHAR *)&dsF57EXPDT.edfb01);<br/>						//<br/>						if (dsF57EXPDT.edlgop == _J('L') || dsF57EXPDT.edlgop == _J('V')) // Verifica se é literal ou variavel<br/>						{<br/>							//							<br/>							I57EVAL_ParseValor(szItemDados, dsF57EXPDT.edfb01, &dados);<br/>							NodoTemporario = I57EVAL_CriarNovoNodo(szItemDados, dados);<br/>							I57EVAL_Empilha(_J("NA"), &PilhaNo, NodoTemporario);<br/>							//<br/>						} else if (dsF57EXPDT.edlgop == _J('O')) {<br/>							//<br/>							if (PilhaOperandos.Cabeca-&gtData == NULL) // Verifica se a pilha ta vazia <br/>							{<br/>								//<br/>								I57EVAL_Empilha(szItemDados, &PilhaOperandos, dsF57EXPDT.edfb01);<br/>								//<br/>							} else if (I57EVAL_ComparaValor(szItemDados, &PilhaOperandos.Cabeca-&gtData,_J("(")) == 0) {<br/>								//															<br/>								I57EVAL_Empilha(szItemDados, &PilhaOperandos, dsF57EXPDT.edfb01);<br/>								//<br/>							} else if (I57EVAL_Precedencia(dsF57EXPDT.edfb01, (JCHAR *)PilhaOperandos.Cabeca-&gtData)) {<br/>								//<br/>								I57EVAL_Empilha(szItemDados, &PilhaOperandos, dsF57EXPDT.edfb01);<br/>								//<br/>							} else {<br/>								//<br/>								while(PilhaOperandos.Cabeca-&gtData != NULL && I57EVAL_Precedencia(PilhaOperandos.Cabeca-&gtData, dsF57EXPDT.edfb01))<br/>								{<br/>									//<br/>									dados = I57EVAL_DesEmpilha(&PilhaOperandos);<br/>									ArvoreExp-&gtArvores = I57EVAL_CriarNovoNodo(szItemDados, &dados);<br/>									NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>									ArvoreExp-&gtArvores-&gtfilho_direita = NodoTemporario;<br/>									NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>									ArvoreExp-&gtArvores-&gtfilho_esquerda = NodoTemporario;<br/>									//<br/>									NodoTemporario-&gtdata = ArvoreExp-&gtArvores-&gtdata;<br/>									jdeStrncpyTerminate(NodoTemporario-&gtsztipodata, ArvoreExp-&gtArvores-&gtsztipodata, DIM(NodoTemporario-&gtsztipodata));<br/>									NodoTemporario-&gtfilho_direita = ArvoreExp-&gtArvores-&gtfilho_direita;<br/>									NodoTemporario-&gtfilho_esquerda = ArvoreExp-&gtArvores-&gtfilho_esquerda;<br/>									I57EVAL_Empilha(szItemDados, &PilhaNo, &NodoTemporario);<br/>									//<br/>								}<br/>								//<br/>								I57EVAL_Empilha(szItemDados, &PilhaOperandos, dsF57EXPDT.edfb01);<br/>								//<br/>							}<br/>						//							<br/>						} else if (I57EVAL_ComparaValor(szItemDados, dsF57EXPDT.edfb01,_J("(")) == 0) {<br/>							//<br/>							I57EVAL_Empilha(szItemDados, &PilhaOperandos, dsF57EXPDT.edfb01);										<br/>							//<br/>						} else if (I57EVAL_ComparaValor(szItemDados, dsF57EXPDT.edfb01,_J(")")) == 0) {<br/>							//<br/>							dados = I57EVAL_DesEmpilha(&PilhaOperandos);<br/>							//while (I57EVAL_ComparaValor(szItemDados, &PilhaOperandos.Cabeca-&gtData, "(") != 0) {<br/>							while (I57EVAL_ComparaValor(szItemDados, dados, _J("(")) != 0) {<br/>								//								<br/>								ArvoreExp-&gtArvores = I57EVAL_CriarNovoNodo(szItemDados, dados);<br/>								NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>								ArvoreExp-&gtArvores-&gtfilho_direita = NodoTemporario;<br/>								NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>								ArvoreExp-&gtArvores-&gtfilho_esquerda = NodoTemporario;<br/>								//<br/>								NodoTemporario-&gtdata = ArvoreExp-&gtArvores-&gtdata;<br/>								jdeStrncpyTerminate(NodoTemporario-&gtsztipodata, ArvoreExp-&gtArvores-&gtsztipodata, DIM(NodoTemporario-&gtsztipodata));<br/>								NodoTemporario-&gtfilho_direita = ArvoreExp-&gtArvores-&gtfilho_direita;<br/>								NodoTemporario-&gtfilho_esquerda = ArvoreExp-&gtArvores-&gtfilho_esquerda;<br/>								I57EVAL_Empilha(szItemDados, &PilhaNo, &NodoTemporario);<br/>								ArvoreExp-&gtArvores = NULL;<br/>								//<br/>								dados = I57EVAL_DesEmpilha(&PilhaOperandos);<br/>							}<br/>							//<br/>						}<br/>					}<br/>					//<br/>					while ((dados = I57EVAL_DesEmpilha(&PilhaOperandos)) != NULL) {<br/>						//<br/>						ArvoreExp-&gtArvores = I57EVAL_CriarNovoNodo(szItemDados, dados);<br/>						NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>						ArvoreExp-&gtArvores-&gtfilho_direita = NodoTemporario;<br/>						NodoTemporario = I57EVAL_DesEmpilha(&PilhaNo);<br/>						ArvoreExp-&gtArvores-&gtfilho_esquerda = NodoTemporario;<br/>						//<br/>						NodoTemporario-&gtdata = ArvoreExp-&gtArvores-&gtdata;<br/>						jdeStrncpyTerminate(NodoTemporario-&gtsztipodata, ArvoreExp-&gtArvores-&gtsztipodata, DIM(NodoTemporario-&gtsztipodata));<br/>						NodoTemporario-&gtfilho_direita = ArvoreExp-&gtArvores-&gtfilho_direita;<br/>						NodoTemporario-&gtfilho_esquerda = ArvoreExp-&gtArvores-&gtfilho_esquerda;<br/>						I57EVAL_Empilha(szItemDados, &PilhaNo, &NodoTemporario);<br/>						//<br/>					}<br/>					//<br/>				}<br/>				//<br/>			}<br/>			//<br/>		} else {<br/>			//seta erro<br/>			return (ER_ERROR);<br/>		}<br/>    } else  {<br/>	    //seta erro<br/>		return (ER_ERROR);<br/>    }<br/>	//<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>	if (hF57EXPRE) {<br/>		JDB_CloseTable(hF57EXPRE);	<br/>	}<br/>	if (hF57EXPDT)<br/>	{<br/>		JDB_CloseTable(hF57EXPDT);	<br/>	}<br/>	if (hF57EXPCR) <br/>	{<br/>		JDB_CloseTable(hF57EXPCR);	<br/>	}<br/>	//<br/>	ArvoreExp-&gtNumExpressoes = 1;<br/>	lpDS-&gtidExpressao = (ID)jdeStoreDataPtr(hUser, ArvoreExp);	<br/>	//<br/>	return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  DescarregaExpressoes<br/> *<br/> *        Description:  Descarrega Expressoes<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57EVALC        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI DescarregaExpressoes (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALC lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/><br/>   /************************************************************************<br/>    * Declare structures<br/>    ************************************************************************/<br/><br/>   /************************************************************************<br/>    * Declare pointers<br/>    ************************************************************************/<br/><br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>   if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57EVALC)	NULL))<br/>   {<br/>     jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>     return ER_ERROR;<br/>   }<br/><br/>   /************************************************************************<br/>    * Set pointers<br/>    ************************************************************************/<br/><br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/><br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  ExecutaExpressao<br/> *<br/> *        Description:  Executa Expressao<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57EVALB        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI ExecutaExpressao (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALB lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>	HUSER       hUser              = (HUSER)NULL;<br/>	ID          idResultado        = JDEDB_PASSED;<br/>	//<br/>	Arvore_Binaria *ArvoreExp = NULL;<br/>	Nodo_Arvore    *NodoTemporario;<br/>	//<br/><br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57EVALB)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idResultado = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idResultado == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	ArvoreExp = (Arvore_Binaria *)jdeRetrieveDataPtr(hUser, lpDS-&gtidExpressoes);<br/>	I57EVAL_ExecutaExpressao (ArvoreExp-&gtArvores);<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>	return (ER_SUCCESS);<br/>}<br/><br/>/**************************************************************************<br/> *  Business Function:  SetaVariavel<br/> *<br/> *        Description:  Seta Variavel<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57EVALD        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI SetaVariavel (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57EVALD lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>	HUSER           hUser              = (HUSER)NULL;<br/>	ID              idResultado        = JDEDB_PASSED;<br/>	//int             Posicao            = 0;<br/>	DSDDINFO        *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>	Arvore_Binaria *ArvoreExp;<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57EVALD)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idResultado = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idResultado == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//carrega arvore<br/>	//ArvoreExp = (Arvore_Binaria *)jdeRetrieveDataPtr(hUser, lpDS-&gtidCursor);<br/>	//<br/>	lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItem, 0, NULL);<br/>	if (lpItemDados-&gtwStatus == 0) {<br/>		//<br/>		if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) {<br/>			//<br/>			//MathCopy(Variaveis[Posicao].Valor, &lpDS-&gtmnValorNumerico);<br/>			//<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>			//<br/>			//jdeStrcpy (Variaveis[Posicao].Valor, lpDS-&gtszValorString, sizeof(lpDS-&gtszValorString));<br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>			//<br/>			//memcpy((void *)(Variaveis[Posicao].Valor), (const void *)(&lpDS-&gtcValorChar), sizeof(char));<br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>			//<br/>			//memcpy((void *)(Variaveis[Posicao].Valor), (const void *)(&lpDS-&gtjdValorData), sizeof(JDEDATE));<br/>   		    //<br/>		}<br/>		//<br/>	} else {<br/>		//<br/>		return (ER_ERROR);<br/>		//<br/>	}<br/>	//<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>    return (ER_SUCCESS);<br/>}<br/><br/>/* Funções Internas */<br/>//<br/>BOOL I57EVAL_Empilha(JCHAR *szItemDados, struct Pilha *pilha, void *Data)<br/>{<br/>	NodoPilha *NovoNodo =  malloc(sizeof(struct NodoPilha_t));<br/>	if(NovoNodo == NULL)<br/>	{<br/>		return FALSE;<br/>	}<br/>	I57EVAL_CopiaValor(szItemDados, &NovoNodo-&gtData, Data);<br/>	jdeStrcpy((JCHAR *)&NovoNodo-&gtsztipodata,(const JCHAR *)szItemDados);<br/>	NovoNodo-&gtProx = pilha-&gtCabeca;<br/>	pilha-&gtCabeca = NovoNodo;<br/>	pilha-&gtNodos = NovoNodo;<br/>	pilha-&gtNodos-&gtProx = NovoNodo-&gtProx;<br/>	return TRUE;<br/>}<br/>//<br/>void *I57EVAL_DesEmpilha(struct Pilha *pilha)<br/>{<br/>	void *temp = NULL;<br/>	if(pilha-&gtCabeca!=NULL)<br/>	{<br/>		I57EVAL_CopiaValor(pilha-&gtCabeca-&gtsztipodata ,&temp, pilha-&gtCabeca-&gtData);<br/>		pilha-&gtNodos = pilha-&gtCabeca;<br/>		pilha-&gtCabeca = pilha-&gtCabeca-&gtProx;<br/>		free(pilha-&gtNodos);<br/>	}<br/>	return temp;<br/>}<br/>//<br/>void I57EVAL_IniciaPilha(struct Pilha *pilha)<br/>{<br/>	pilha-&gtCabeca = malloc(sizeof(struct NodoPilha_t));<br/>	pilha-&gtNodos = malloc(sizeof(struct NodoPilha_t));<br/>}<br/>//<br/>void I57EVAL_ParseValor (JCHAR *szItemDados, JCHAR *Valor, void **ValorRetorno)<br/>{<br/>	//<br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>	//<br/>	if (jdeStrcmp(szItemDados, _J("NA")) == 0)<br/>	{<br/>		*ValorRetorno = malloc(sizeof(Nodo_Arvore));<br/>		memcpy(*ValorRetorno, Valor, sizeof(Nodo_Arvore));<br/>	} else {<br/>		//<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         : *ValorRetorno = malloc(sizeof(JCHAR)); memcpy(*ValorRetorno, Valor, sizeof(JCHAR)); break;// Char<br/>			case EVDT_STRING       : *ValorRetorno = malloc(sizeof(Valor)); jdeStrncpyTerminate((JCHAR *)*ValorRetorno, (JCHAR *)Valor, DIM(Valor)); break;// String<br/>			case EVDT_MATH_NUMERIC : *ValorRetorno = malloc(sizeof(MATH_NUMERIC)); ParseNumericStringEx((MATH_NUMERIC*)*ValorRetorno, (JCHAR *)Valor,DEFAULT_SEPARATOR);break;// Math Numeric<br/>			//case EVDT_INT          : *ValorRetorno = malloc(sizeof(int)); memcpy(*ValorRetorno, Valor, sizeof(int)); break;// integer<br/>			//case EVDT_JDEDATE      : *ValorRetorno = malloc(sizeof(JDEDATE)); memcpy(*ValorRetorno, Valor, sizeof(JDEDATE));break;// Date<br/>			default: break;<br/>		}<br/>		//<br/>	}<br/>	//<br/>}<br/>//<br/>int I57EVAL_CopiaValor (JCHAR *szItemDados, void **ValorDestino, void *ValorOrigem)<br/>{<br/>	// <br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>	//<br/>	if (jdeStrcmp(szItemDados, _J("NA")) == 0) <br/>	{<br/>		*ValorDestino = malloc(sizeof(Nodo_Arvore));<br/>		memcpy(*ValorDestino, ValorOrigem, sizeof(Nodo_Arvore));<br/>	} else {<br/>		//<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         : *ValorDestino = malloc(sizeof(JCHAR)); memcpy(*ValorDestino, ValorOrigem, sizeof(JCHAR)); break;// Char<br/>			//case EVDT_STRING       : *ValorDestino = malloc(sizeof(ValorOrigem)); jdeStrncpyTerminate((JCHAR *)*ValorDestino, (JCHAR *)ValorOrigem, DIM((JCHAR *)ValorOrigem)); break;// String<br/>			case EVDT_MATH_NUMERIC : *ValorDestino = malloc(sizeof(MATH_NUMERIC)); memcpy(*ValorDestino, ValorOrigem, sizeof(MATH_NUMERIC));break;// Math Numeric<br/>			case EVDT_INT          : *ValorDestino = malloc(sizeof(int)); memcpy(*ValorDestino, ValorOrigem, sizeof(int)); break;// integer<br/>			case EVDT_JDEDATE      : *ValorDestino = malloc(sizeof(JDEDATE)); memcpy(*ValorDestino, ValorOrigem, sizeof(JDEDATE));break;// Date<br/>			default : return 1;<br/>				break;<br/>		}<br/>		//<br/>	}<br/>	//<br/>	return 0;<br/>}<br/>//<br/>int I57EVAL_ComparaValor (JCHAR *szItemDados, void *Valor1, void *Valor2) <br/>{<br/>	//<br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>	//<br/>	switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>		case EVDT_CHAR         :	if ( *(JCHAR *)Valor1 &gt *(JCHAR *)Valor2 )  {<br/>			                           return 1;  <br/>								 } else if ( *(JCHAR *)Valor1 &lt *(JCHAR *)Valor2 ) {<br/>									   return -1;<br/>								 } else if ( *(JCHAR *)Valor1 == *(JCHAR *)Valor2 ) {<br/>									   return 0;<br/>								 }<br/>							break;// Char<br/>		case EVDT_STRING       :	return jdeStrcmp((JCHAR *)(Valor1), (JCHAR *)(Valor2));<br/>								break;// String<br/>		case EVDT_MATH_NUMERIC :	return MathCompare ((MATH_NUMERIC *)(Valor1), (MATH_NUMERIC *)(Valor2));<br/>								break;// Math Numeric<br/>		case EVDT_INT          :	 if ((int)(Valor1) &lt (int)Valor2) {<br/>										return 1;<br/>									} else if ((int)(Valor1) &gt (int)(Valor2)) {<br/>										return -1;<br/>									} else if ((int)(Valor1) == (int)(Valor2)) {<br/>										return 0;<br/>									}<br/>								break;// integer<br/>		//case EVDT_JDEDATE      :	return JDEDATECmp((JDEDATE *)(Valor1), (JDEDATE *)(Valor2));<br/>		//						break;// Date<br/>		default                :	return 1;<br/>								break;//não suportado<br/>	}<br/>	//<br/>	return 0;<br/>}<br/>//<br/>Arvore_Binaria *I57EVAL_CriarArvore(JCHAR *Nome)<br/>{<br/>	//<br/>	Arvore_Binaria *Arv;<br/>	Arv = (Arvore_Binaria*)malloc(sizeof(Arvore_Binaria));<br/>	jdeStrncpy(Arv-&gtNome, Nome, DIM(Arv-&gtNome));<br/>    //<br/>	return Arv;<br/>	//Arv-&gtArvores = malloc(sizeof(Nodo_Arvore) * NumExps);<br/>	//<br/>} <br/>//Cria novo nodo na arvore<br/>Nodo_Arvore *I57EVAL_CriarNovoNodo(JCHAR *szItemDados, void *Data)<br/>{<br/>   //<br/>   Nodo_Arvore *NovoNodo = (Nodo_Arvore*)malloc(sizeof(Nodo_Arvore));<br/>   //<br/>   NovoNodo-&gtfilho_esquerda = NULL;<br/>   NovoNodo-&gtfilho_direita  = NULL;<br/>   jdeStrncpyTerminate(NovoNodo-&gtsztipodata, szItemDados, DIM(NovoNodo-&gtsztipodata));<br/>   I57EVAL_CopiaValor(szItemDados ,&NovoNodo-&gtdata, Data);<br/>   return NovoNodo;<br/>   //<br/>}<br/>//retorna verdadeiro se A for maior que B<br/>BOOL I57EVAL_Precedencia(JCHAR *OperadorA, JCHAR *OperadorB)<br/>{<br/>   if (jdeStrcmp(OperadorA,_J("SE")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(OperadorB,_J("SE")) == 0) <br/>	   return FALSE;<br/>   else if (jdeStrcmp(OperadorA,_J("(")) == 0)<br/>       return FALSE;<br/>   else if (jdeStrcmp(OperadorB,_J("(")) == 0)<br/>       return FALSE;<br/>   else if (jdeStrcmp(OperadorB,_J(")")) == 0)<br/>       return TRUE;<br/>   else if (jdeStrcmp(OperadorA,_J("^")) == 0 && jdeStrcmp(OperadorB,_J("^")) == 0)<br/>       return FALSE;<br/>   else if (jdeStrcmp(OperadorA,_J("^")) == 0)<br/>       return TRUE;<br/>   else if (jdeStrcmp(OperadorB,_J("^")) == 0)<br/>       return FALSE;<br/>   else if (jdeStrcmp(OperadorA,_J("*")) == 0 || jdeStrcmp(OperadorA,_J("/")) == 0)<br/>       return TRUE;<br/>   else if (jdeStrcmp(OperadorB,_J("*")) == 0 || jdeStrcmp(OperadorB,_J("/")) == 0)<br/>       return FALSE;<br/>   else if (jdeStrcmp(OperadorA,_J("&gt")) == 0 || jdeStrcmp(OperadorA,_J("&lt")) == 0 || jdeStrcmp(OperadorA,_J("&lt=")) == 0 || <br/>			jdeStrcmp(OperadorA,_J("&gt=")) == 0 || jdeStrcmp(OperadorA ,_J("E")) == 0 || jdeStrcmp(OperadorA,_J("OU")) == 0)<br/>	   return FALSE;<br/>   else<br/>       return TRUE;   <br/>}<br/>//<br/>JCHAR *I57EVAL_TipoDado(HREQUEST *hF57EXPCR, JCHAR *Chave)<br/>{<br/>	F57EXPCR		dsRegistro;<br/>	KEY1_F57EXPCR   dsF57EXPCRKey;<br/>	//<br/>	jdeStrncpyTerminate(dsF57EXPCRKey.crmsdt, Chave, DIM(dsF57EXPCRKey.crmsdt));<br/>	//<br/>	JDB_FetchKeyed( hF57EXPCR, ID_F57EXPCR_PK, (void *) &dsF57EXPCRKey, (short) 1, &dsRegistro, 0);<br/>	//<br/>	return dsRegistro.crobnd;<br/>}<br/>//<br/>void I57EVAL_RemoveSurroundingBlanks(JCHAR * szString)<br/>{<br/>	<br/>	unsigned int	ni;<br/>	JCHAR	*p;<br/>	JCHAR	*s;<br/>	JCHAR	*pi;<br/> <br/>	ni = jdeStrlen(szString);		/* Get initial length of string */<br/>	s = (JCHAR *) calloc(ni+1, sizeof(*s));  /* allow for the null char at end of string */<br/>	jdeStrncpy(s, (const JCHAR *) szString, ni);<br/>	pi = s;<br/><br/>	if (*s != _J('\0'))<br/>	{	while (jdeIsspace(*s) && *s != _J('\0'))	/* Skip leading spaces */<br/>			++s;<br/>		p = s;<br/>		<br/>		if (*s)								/* Proceed if remaining string is not null */<br/>		{<br/>			for (;*s != _J('\0'); ++s);			/* go to end of string */<br/>			--s;							/* back up one char to point to last char in string */<br/>			while (jdeIsspace(*s))				/* remove spaces from end of string */<br/>			{<br/>				*s = _J('\0');<br/>				--s;<br/>			}<br/>		}<br/>		jdeStrncpy(szString, (const JCHAR *) p, ni);<br/>	}<br/>	free(pi);<br/>}<br/>//<br/>void I57EVAL_strpadl (JCHAR *lpszString, const JCHAR *szPad, size_t nLen) <br/>{<br/>   JCHAR     szS2[255];<br/>   int      nCount   = 0;<br/>   int      nBefore  = 0;<br/>   int      nSize    = 0;<br/>   <br/>   nSize = jdeStrlen(lpszString);<br/>   nBefore = (nLen - nSize);<br/>   <br/>   if (nBefore &gt= 0)<br/>   {<br/>      for (nCount = 1; nCount &lt= nBefore; nCount++)<br/>      {<br/>         jdeStrcat ((JCHAR *)szS2,(JCHAR *)szPad);<br/>      }<br/>      jdeStrcat ((JCHAR *)szS2, (JCHAR *)lpszString);<br/>   }<br/>   else<br/>   {<br/>      jdeStrncpy((JCHAR *)lpszString, (JCHAR *)lpszString, nLen);<br/>   }<br/>   <br/>   jdeStrcpy((JCHAR *)lpszString, (JCHAR *)szS2);<br/>   <br/>   return;<br/><br/>}<br/>//<br/>void I57EVAL_strpadr (JCHAR *lpszString, const JCHAR *szPad, size_t nLen) <br/>{<br/>   int      nCount   = 0;<br/>   int      nAfter   = 0;<br/>   int      nSize    = 0;<br/>   <br/>   nSize = jdeStrlen(lpszString);<br/>   nAfter = (nLen - nSize);<br/>   <br/>   if (nAfter &gt= 0)<br/>   {<br/>      for (nCount = 1; nCount &lt= nAfter; nCount++)<br/>      {<br/>         jdeStrcat ((JCHAR *)lpszString, (JCHAR *)szPad);<br/>      }<br/>   }<br/>   else<br/>   {<br/>      jdeStrncpy((JCHAR *)lpszString, (JCHAR *)lpszString, nLen);<br/>   }<br/>   return;<br/><br/>}<br/>//<br/>void I57EVAL_ExecutaExpressao (Nodo_Arvore *Raiz)<br/>{<br/>	if(I57EVAL_Operador(Raiz-&gtdata) && !I57EVAL_Operador(Raiz-&gtfilho_esquerda-&gtdata) && !I57EVAL_Operador(Raiz-&gtfilho_direita-&gtdata))<br/>	{<br/>		//executa a operação e guarda o valor no raiz<br/>		Raiz-&gtdata = I57EVAL_ExecutaOperador((JCHAR *)Raiz-&gtdata, Raiz-&gtfilho_esquerda, Raiz-&gtfilho_direita);<br/>		Raiz-&gtfilho_esquerda = NULL;<br/>		Raiz-&gtfilho_direita = NULL;<br/>	}<br/>	else if(Raiz-&gtfilho_esquerda == NULL && Raiz-&gtfilho_direita == NULL);<br/>	else<br/>	{<br/>		I57EVAL_ExecutaExpressao(Raiz-&gtfilho_esquerda);<br/>		I57EVAL_ExecutaExpressao(Raiz-&gtfilho_direita);<br/>		I57EVAL_ExecutaExpressao(Raiz);<br/>	}<br/><br/>}<br/>//<br/>BOOL I57EVAL_Operador(JCHAR *Operador)<br/>{<br/>   if (jdeStrcmp(Operador,_J("(")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J(")")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("+")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("-")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("*")) == 0) <br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("/")) == 0)  <br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("SE")) == 0)  <br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("OU")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("E")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("^")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("&gt")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("&lt")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("&gt=")) == 0)<br/>	   return TRUE;<br/>   else if (jdeStrcmp(Operador,_J("&lt=")) == 0)<br/>	   return TRUE;<br/>	return FALSE;<br/>};<br/>//<br/>void *I57EVAL_ExecutaOperador(JCHAR *Operador, Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	if (jdeStrcmp(Operador,_J("+")) == 0)<br/>		return I57EVAL_Soma(Esquerda, Direita);	<br/>    else if (jdeStrcmp(Operador,_J("-")) == 0)<br/>		return I57EVAL_Subtracao(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("*")) == 0) <br/>		return I57EVAL_Multiplicacao(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("/")) == 0)  <br/>		return I57EVAL_Divisao(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("SE")) == 0)  <br/>		return (void *)I57EVAL_SE(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("OU")) == 0)<br/>		return (void *)I57EVAL_OU(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("E")) == 0)<br/>		return (void *)I57EVAL_E(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("^")) == 0)<br/>		return I57EVAL_Exponenciacao(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("&gt")) == 0)<br/>		return (void *)I57EVAL_Maior(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("&lt")) == 0)<br/>		return (void *)I57EVAL_Menor(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("&gt=")) == 0)<br/>		return (void *)I57EVAL_MaiorIgual(Esquerda, Direita);<br/>    else if (jdeStrcmp(Operador,_J("&lt=")) == 0)<br/>		return (void *)I57EVAL_MenorIgual(Esquerda, Direita);<br/>	else return NULL;<br/>};<br/>//<br/>void *I57EVAL_Soma(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	// <br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>	if ((jdeStrcmp(Esquerda-&gtsztipodata, Direita-&gtsztipodata) == 0))<br/>	{<br/>		// soma de acordo com o tipo <br/>	    lpItemDados = jdeDDCreate(NULL, Esquerda-&gtsztipodata, 0, NULL);<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         : <br/>				break;// Char<br/>			case EVDT_STRING       : <br/>				break;// String<br/>			case EVDT_MATH_NUMERIC : <br/>				break;// Math Numeric<br/>			case EVDT_INT          : <br/>				break;// integer<br/>			case EVDT_JDEDATE      : <br/>				break;// Date<br/>			default : return (void *)1;<br/>				break;<br/>		}<br/>		//<br/>	} else {<br/>		// converte tudo pra string <br/>	<br/>		//<br/>	}<br/>	return NULL;<br/>};<br/>//<br/>void *I57EVAL_Subtracao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return NULL;<br/>};<br/>//<br/>void *I57EVAL_Divisao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return NULL;<br/>};<br/>//<br/>void *I57EVAL_Multiplicacao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return NULL;<br/>};<br/>//<br/>BOOL I57EVAL_Igual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_Maior(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_Menor(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_MaiorIgual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_MenorIgual(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>void *I57EVAL_Exponenciacao(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return NULL;<br/>};<br/>//<br/>BOOL I57EVAL_E(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_OU(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	return TRUE;<br/>};<br/>//<br/>BOOL I57EVAL_SE(Nodo_Arvore *Esquerda, Nodo_Arvore *Direita)<br/>{<br/>	// <br/>	//DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>	return TRUE;<br/>};<br/>//<br/>void *I57EVAL_ValorVariavel(JCHAR *szNomeVariavel)<br/>{<br/>	//<br/>	return NULL;<br/>	//<br/>}<br/>//<br/>ID I57EVAL_CarregaVariaveis(HUSER hUser, JCHAR *szNomeProcesso, JCHAR *szNomeExpressao, ListaVariaveis *lv)<br/>{<br/>	ID			    idResultado        = JDEDB_PASSED;<br/>	HREQUEST		hF57EXPVA          = (HREQUEST)NULL; // Handle tabela de variaveis<br/>	F57EXPVA		dsF57EXPVA;<br/>	KEY1_F57EXPVA   dsF57EXPVAKey;<br/>	//ListaVariaveis  lv; <br/>	int				NumRecords		   = 0;<br/>	int				NumRecord		   = 0;<br/>	//<br/>	idResultado = JDB_OpenTable(hUser, _J("F57EXPVA"), 0, NULL, 0, NULL, &hF57EXPVA); 	<br/>	if (idResultado == JDEDB_PASSED)<br/>	{<br/>		//<br/>		//monta chave select<br/> 		idResultado = JDB_ClearColBuffer(hF57EXPVA, &dsF57EXPVA); <br/>		//<br/>     	jdeStrncpyTerminate(dsF57EXPVAKey.evprocess, szNomeProcesso, DIM(dsF57EXPVAKey.evprocess));<br/>		jdeStrncpyTerminate(dsF57EXPVAKey.evaa12, szNomeExpressao, DIM(dsF57EXPVAKey.evaa12));<br/>		//<br/>		NumRecords = JDB_SelectKeyedGetCount(hF57EXPVA, ID_F57EXPVA_PK, (void *) &dsF57EXPVAKey, (short) 1);<br/>		//<br/>		if (NumRecords &gt 0)<br/>		{<br/>			//<br/>			*lv = malloc(sizeof(NodoVariavel) * NumRecords); <br/>			//<br/>		} else {<br/>			//<br/>			return (ER_ERROR);<br/>			//<br/>		}<br/>		//<br/>		idResultado = JDB_SelectKeyed( hF57EXPVA, ID_F57EXPVA_PK, (void *) &dsF57EXPVAKey, (short) 1);<br/>		//<br/>		if (idResultado == JDEDB_PASSED) <br/>		{<br/>			//<br/>			while (JDB_FetchMatchingKey(hF57EXPVA, (void *)&dsF57EXPVAKey, (short)2, (void *)&dsF57EXPVA, (int)FALSE) == JDEDB_PASSED)<br/>			{<br/>				//<br/>				jdeStrncpyTerminate(lv[0][NumRecord].NomeVariavel, dsF57EXPVA.evva01, DIM(dsF57EXPVA.evva01));	<br/>				lv[0][NumRecord].Valor = NULL;<br/>				//I57EVAL_CopiaValor(lv[NumRecord].Valor, , NULL);<br/>				NumRecord++;<br/>				//<br/>			}<br/>			//<br/>		} else <br/>		{<br/>			//<br/>			return ER_ERROR ;<br/>			//<br/>		}<br/>		//<br/>	} else <br/>	{<br/>		//<br/>		return ER_ERROR ;<br/>		//<br/>	}<br/>	//<br/>	if (hF57EXPVA != NULL) <br/>	{<br/>		JDB_CloseTable(hF57EXPVA);<br/>	}<br/>	return ER_SUCCESS;<br/>};<br/>//<br/>ID I57EVAL_BuscaValorVariavelUBE(LPBHVRCOM lpBhvrCom, HUSER hUser, ListaVariaveis *lv)<br/>{<br/>    DBREF                DbRef;            <br/>    LPCOLINFO            lpColInfo               = (LPCOLINFO)NULL;<br/>	DSDDINFO			 *lpItemDados			 = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	int					 NumVariavel		     = 0;<br/>	//<br/>	NumVariavel++;<br/>	jdeNIDcpy(DbRef.szTable, lv[0]-&gtNomeTabela);<br/>    DbRef.idInstance = 0;<br/>    jdeNIDcpy(DbRef.szDict, lv[0]-&gtNomeCampo);<br/>	//<br/>    lpColInfo = (LPCOLINFO)ubeSection_GetTableInfo (lpBhvrCom, DbRef);<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, lv[0]-&gtNomeCampo, 0, NULL);<br/>	//<br/>	switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         : lv[0]-&gtValor = malloc(sizeof(JCHAR)); memcpy(lv[0]-&gtValor, lpColInfo-&gtlpJDEValue, sizeof(JCHAR)); break;// Char<br/>			//case EVDT_STRING       : lv[0]-&gtValor = malloc(sizeof(lpColInfo-&gtlpJDEValue)); jdeStrncpyTerminate((JCHAR *)lv[0]-&gtValor, (JCHAR *)lpColInfo-&gtlpJDEValue, DIM((JCHAR *)lpColInfo-&gtlpJDEValue)); break;// String<br/>			case EVDT_MATH_NUMERIC : lv[0]-&gtValor = malloc(sizeof(MATH_NUMERIC)); memcpy(lv[0]-&gtValor, lpColInfo-&gtlpJDEValue, sizeof(MATH_NUMERIC));break;// Math Numeric<br/>			case EVDT_INT          : lv[0]-&gtValor = malloc(sizeof(int)); memcpy(lv[0]-&gtValor, lpColInfo-&gtlpJDEValue, sizeof(int)); break;// integer<br/>			case EVDT_JDEDATE      : lv[0]-&gtValor = malloc(sizeof(JDEDATE)); memcpy(lv[0]-&gtValor, lpColInfo-&gtlpJDEValue, sizeof(JDEDATE));break;// Date<br/>     		default                :<br/>								break;//não suportado<br/>	}<br/>	//<br/>	return ER_SUCCESS;<br/>}<br/><br/></pre></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Executa Expressão - [DescarregaExpressoes]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57EVALC - Estrutura de Dados da Função B57EVAL                        </B><BR>BF idExpressoes [GENLNG]<BR>BF cRetorno [ERRC]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Executa Expressão - [ExecutaExpressao]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57EVALB - Estrutura de Dados da Função B57EVAL                        </B><BR>BF idExpressoes [GENLNG]<BR>BF szNomeExpressao [AA12]<BR>BF cRetorno [ERRC]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Executa Expressão - [SetaVariavel]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57EVALD - Estrutura de Dados da Função B57EVAL                        </B><BR>BF szVariavel [AA12]<BR>BF idExpressao [GENLNG]<BR>BF szDataItem [OBND]<BR>BF cCodigoErro [ERRC]<BR>BF szValorString [AA40]<BR>BF mnValorNumerico [VLRTOTLI]<BR>BF jdValorData [UPMJ]<BR>BF cValorChar [EV01]<BR>BF nValorInteiro [CIP]<BR></div></div></div></body></html>