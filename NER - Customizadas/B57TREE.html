<!DOCTYPE html><html lang = "en"><head><meta charset = "utf-8"><meta name = "viewport" content = "width=device-width, initial-scale=1"><title>JDE Object Browser HTML Extract</title>
<style type='text/css'>body,th{font-family: Courier New, Courier, mono;font-size: 12px; width:auto}
.section{font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width: 100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.objectheader {font-family: Arial, Helvetica, sans-serif;font-size: 12px;font-weight: bold;border: thin groove #CC9966;width:auto;background-color: #FFFFCC;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.details{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:100%;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px;box-sizing: border-box }
.er {background-color: #FFFFFF;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal; border: thin solid #CCCCCC; width:auto; padding-left: 5px;padding-top: 5px;padding-bottom: 5px; padding-right: 5px; box-sizing: border-box }
.dstrmembers {background-color: #FFFDDD;font-family: Courier New, Courier, mono;font-size: 12px;border: thin groove #CC9966;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; box-sizing: border-box }
.disabled {font-family: Courier New, Courier, mono;font-size: 12px;	font-style: italic; color:#CC9933}
.parameters {font-family: Courier New, Courier, mono;font-size: 12px; color:#3333FF}
.comment {font-family: Courier New, Courier, mono;font-size: 12px;	color: #339933}
.subtable {font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;width:100%}
.lineno {color:#6E6E6E;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.iokey {color:#FF6905;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.logicline {color:#000000;font-family: Courier New, Courier, mono;font-size: 12px; font-weight: normal;}
.versionoverride {background-color: #FFCC99;}
.overrideflags{font-family: Arial, Helvetica, sans-serif;font-size: 11px;font-weight: normal;border: thin groove #CC9966;width:auto;padding-left: 5px;padding-top: 5px;padding-bottom: 5px;padding-right: 5px; background-color: #FFCC99; box-sizing: border-box }
.bsfnprops {font-family: Courier New, Courier, mono;font-size: 12px; color:#E01B4C}
.searchresult {font-family: Courier New, Courier, mono;font-size: 12px; font-weight: bold; background-color:#8BF3A0}
.expand {font-family: Courier New, Courier, mono;font-size: 11px; font-weight: bold; cursor:pointer; border: 1px solid gray; position: relative; left: -3px; display:inline; line-height:8px;}
.expand2 { display:inline; cursor:pointer; font-size: 9px; border: 1px solid gray; position: relative; left: -3px;}
</style>
<script type='text/javascript'>function load(){location.href = '#result';}</script>
<script language='JavaScript' type='text/javascript'>function ExpandCollapse(ElementId){ var ClickedElement = document.getElementById(ElementId); var SectionName = ElementId + ':hide'; var Section = document.getElementById(SectionName); if (ClickedElement.innerHTML == '-') { 	 ClickedElement.innerHTML = '+';	Section.style.display = 'none'; }  else  { 		ClickedElement.innerHTML = '-'; 	Section.style.display = 'inline';}} </script>
<base target = "_parent"></head><body onload='load()'>
<div class ='objectheader'>Business Function: B57TREE - Implementação de Arvore<BR>Function Type: C</div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [AtualizaNodoCampo]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEM - Atualiza o Campo de um Nodo da Arvore                       </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemCampo [DTAI]<BR>BF szNomeCampo [AA20]<BR>BF mnMathNumeric [CNTF]<BR>BF cChar [EV01]<BR>BF szString [BRD60]<BR>BF nInteger [CIP]<BR>BF jdData [UPMJ]<BR>BF cAtualizarPais [EV01]<BR>BF szFuncaoFormula [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF nIntegerChave [CIP]<BR>BF szStringChave [BRD60]<BR>BF jdDataChave [UPMJ]<BR></div><pre><div class='dstrmembers'><B>Header File: b57tree.h</B><BR></div><br/>/*****************************************************************************<br/> *    Header File:  B57TREE.h<br/> *<br/> *    Description:  Implementação de Arvore Header File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 19/05/10                Unknown  - Created  <br/> *<br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source <br/> * Company.  All rights reserved.  The methods and techniques described <br/> * herein are considered trade secrets and/or confidential.  Reproduction<br/> * or distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/><br/>#ifndef __B57TREE_H<br/>#define __B57TREE_H<br/><br/><br/>#define P 0.5<br/>#define MAX_LEVEL 12<br/><br/><br/>/*****************************************************************************<br/> * Table Header Inclusions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * External Business Function Header Inclusions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * Structure Definitions<br/> ****************************************************************************/<br/>typedef struct tagDDINFO { <br/>	<br/>	LPGLOBALCOL lpGlobalCol; <br/>	LPVOID lpValue; <br/>	PJSTR lpScreenValue; <br/>	WORD wStatus; <br/>	DWORD dwOverrideFlag; <br/>	LPDDEDIT lpEditRules; <br/>	LPDDFORMAT lpFormatRules; <br/>	<br/>} DSDDINFO;<br/>//<br/>//=============================================================//<br/>//                                                             //<br/>//estrutura da pilha usada para carregar a arvore de uma tabela//<br/>//                                                             //<br/>//=============================================================//<br/>struct NodoPilha{<br/>	void   *Data;<br/>	struct NodoPilha *Link;<br/>};<br/>//<br/>struct Pilha{<br/>	struct NodoPilha *Cabeca;<br/>	struct NodoPilha *Nodos;<br/>};<br/>//=============================================================//<br/>//estrutura da pilha usada para carregar a arvore de uma tabela//<br/>//=============================================================//<br/>//<br/>//=============================================================//<br/>//           est. dos campos de cada nodo da arvore            //<br/>//=============================================================//<br/>typedef struct Campo{<br/>	JCHAR Nome[11];<br/>	void *Valor;<br/>} Data;<br/>//=============================================================//<br/>//           est. dos campos de cada nodo da arvore            //<br/>//=============================================================//<br/>//<br/>//=============================================================//<br/>//                    estrutura da arvore                      //<br/>//=============================================================//<br/>typedef void* Chave;<br/>//Estrutura da Arvore<br/>typedef struct EstNodoArvore{<br/>  Chave  chave;<br/>  JCHAR   szItemDadosChave[11];<br/>  Data   *Campos;<br/>  int    nNumElementos;<br/>  int    nNumAlocados;<br/>  int    nNumFilhos;<br/>  struct EstNodoArvore *Pai;<br/>  struct EstNodoArvore *UltimoFilho; <br/>  struct EstNodoArvore *UltimoIrmao; <br/>} NodoArvore, *PNodoArvore; //PNodo = Ponteiro Nodo<br/>//=============================================================//<br/>//                    estrutura da arvore                      //<br/>//=============================================================//<br/>//<br/>//=============================================================//<br/>//                       indice da arvore                      //<br/>//=============================================================//<br/>//<br/>struct sn {<br/>    Chave chave;<br/>	PNodoArvore Link;<br/>    struct sn ** forward; /* Ponteiro pro vetor de ponteiros */<br/>};<br/>typedef struct sn SkipNodo;<br/><br/>typedef struct {<br/>    SkipNodo* header;<br/>    int level;<br/>} SkipList;<br/>//<br/>//=============================================================//<br/>//                       indice da arvore                      //<br/>//=============================================================//<br/>//<br/>typedef struct EstArvore {<br/>	PNodoArvore  Arvore;<br/>	SkipList     *Indice;<br/>} EstruturaArvore;<br/>//<br/>/*****************************************************************************<br/> * Global Definitions<br/> ****************************************************************************/<br/><br/>/*****************************************************************************<br/> * DS Template Type Definitions<br/> ****************************************************************************/<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Inicializa Estrutura de Arvore<br/> *    Template ID:   D57TREEA<br/> *    Generated:     Thu May 20 10:11:39 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEA<br/>#define DATASTRUCTURE_D57TREEA<br/><br/>typedef struct tagDSD57TREEA<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>} DSD57TREEA, *LPDSD57TREEA;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Finaliza Estrutura de Arvore<br/> *    Template ID:   D57TREEB<br/> *    Generated:     Tue Jun 08 08:30:45 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEB<br/>#define DATASTRUCTURE_D57TREEB<br/><br/>typedef struct tagDSD57TREEB<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  ID                idChaves;                            <br/>} DSD57TREEB, *LPDSD57TREEB;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRidChaves_4                           4L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Insere na  Estrutura de Arvore<br/> *    Template ID:   D57TREEC<br/> *    Generated:     Thu May 20 10:12:02 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEC<br/>#define DATASTRUCTURE_D57TREEC<br/><br/>typedef struct tagDSD57TREEC<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>} DSD57TREEC, *LPDSD57TREEC;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Busca Campo do Registro Sendo Processado da Tabela<br/> *    Template ID:   D57TREED<br/> *    Generated:     Mon May 24 14:34:37 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREED<br/>#define DATASTRUCTURE_D57TREED<br/><br/>typedef struct tagDSD57TREED<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  ID                idTabela;                            <br/>  JCHAR              szCampo[11];                         <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              szString[61];                        <br/>  JCHAR              cChar;                               <br/>  JDEDATE           jdData;                              <br/>  int               nInteger;                            <br/>  JCHAR              szIdTabela[11];                      <br/>} DSD57TREED, *LPDSD57TREED;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRidTabela_4                           4L<br/>#define IDERRszCampo_6                            6L<br/>#define IDERRmnMathNumeric_7                      7L<br/>#define IDERRszString_8                           8L<br/>#define IDERRcChar_9                              9L<br/>#define IDERRjdData_10                            10L<br/>#define IDERRnInteger_11                          11L<br/>#define IDERRszIdTabela_12                        12L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Deleta Nodo da Arvore<br/> *    Template ID:   D57TREEE<br/> *    Generated:     Thu May 20 10:12:19 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEE<br/>#define DATASTRUCTURE_D57TREEE<br/><br/>typedef struct tagDSD57TREEE<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>} DSD57TREEE, *LPDSD57TREEE;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Pesquisa Nodo da Arvore<br/> *    Template ID:   D57TREEF<br/> *    Generated:     Mon May 31 12:56:10 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEF<br/>#define DATASTRUCTURE_D57TREEF<br/><br/>typedef struct tagDSD57TREEF<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  JCHAR              szStringChave[61];                   <br/>  int               nIntegerChave;                       <br/>  JDEDATE           jdDataChave;                         <br/>} DSD57TREEF, *LPDSD57TREEF;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRszDataItemChave_4                    4L<br/>#define IDERRmnMathNumericChave_5                 5L<br/>#define IDERRcCharChave_6                         6L<br/>#define IDERRszStringChave_7                      7L<br/>#define IDERRnIntegerChave_8                      8L<br/>#define IDERRjdDataChave_9                        9L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Monta Arvore a Partir de Tabela<br/> *    Template ID:   D57TREEG<br/> *    Generated:     Wed May 26 10:58:13 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEG<br/>#define DATASTRUCTURE_D57TREEG<br/><br/>typedef struct tagDSD57TREEG<br/>{<br/>  ID                idChaves;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  int               nNumChaves;                          <br/>  JCHAR              szIdItemPai[11];                     <br/>  JCHAR              szIdItemFilho[11];                   <br/>  JCHAR              szIdTabela[11];                      <br/>  JCHAR              szCriaCampos[61];                    <br/>  ID                idArvore;                            <br/>  JCHAR              cTipoPaiFilho;                       <br/>  MATH_NUMERIC      mnMathNumericRaiz;                   <br/>  JCHAR              cCharRaiz;                           <br/>  JCHAR              szStringRaiz[61];                    <br/>  int               nIntegerRaiz;                        <br/>  JDEDATE           jdDataRaiz;                          <br/>} DSD57TREEG, *LPDSD57TREEG;<br/><br/>#define IDERRidChaves_2                           2L<br/>#define IDERRcCodigoErro_7                        7L<br/>#define IDERRszDescricaoErro_8                    8L<br/>#define IDERRnNumChaves_10                        10L<br/>#define IDERRszIdItemPai_12                       12L<br/>#define IDERRszIdItemFilho_15                     15L<br/>#define IDERRszIdTabela_16                        16L<br/>#define IDERRszCriaCampos_17                      17L<br/>#define IDERRidArvore_18                          18L<br/>#define IDERRcTipoPaiFilho_19                     19L<br/>#define IDERRmnMathNumericRaiz_20                 20L<br/>#define IDERRcCharRaiz_21                         21L<br/>#define IDERRszStringRaiz_22                      22L<br/>#define IDERRnIntegerRaiz_23                      23L<br/>#define IDERRjdDataRaiz_25                        25L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Estrutura de Dados Padrão de Campos<br/> *    Template ID:   D57TREEH<br/> *    Generated:     Thu May 20 10:13:30 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEH<br/>#define DATASTRUCTURE_D57TREEH<br/><br/>typedef struct tagDSD57TREEH<br/>{<br/>  ID                idCampos;                            <br/>} DSD57TREEH, *LPDSD57TREEH;<br/><br/>#define IDERRidCampos_1                           1L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Inclusão de Chaves para Carga via tabela<br/> *    Template ID:   D57TREEJ<br/> *    Generated:     Thu May 20 15:02:52 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEJ<br/>#define DATASTRUCTURE_D57TREEJ<br/><br/>typedef struct tagDSD57TREEJ<br/>{<br/>  ID                idChaves;                            <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              szString[61];                        <br/>  JCHAR              cChar;                               <br/>  JDEDATE           jdData;                              <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  int               nNumChaves;                          <br/>  int               nNumChave;                           <br/>  JCHAR              szIdTabela[11];                      <br/>  JCHAR              szIdChave[11];                       <br/>} DSD57TREEJ, *LPDSD57TREEJ;<br/><br/>#define IDERRidChaves_2                           2L<br/>#define IDERRmnMathNumeric_3                      3L<br/>#define IDERRszString_4                           4L<br/>#define IDERRcChar_5                              5L<br/>#define IDERRjdData_6                             6L<br/>#define IDERRcCodigoErro_7                        7L<br/>#define IDERRszDescricaoErro_8                    8L<br/>#define IDERRnNumChaves_10                        10L<br/>#define IDERRnNumChave_11                         11L<br/>#define IDERRszIdTabela_16                        16L<br/>#define IDERRszIdChave_17                         17L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Cria Campos<br/> *    Template ID:   D57TREEI<br/> *    Generated:     Mon May 24 14:30:50 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEI<br/>#define DATASTRUCTURE_D57TREEI<br/><br/>typedef struct tagDSD57TREEI<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  ID                idChaves;                            <br/>  ID                idTabela;                            <br/>} DSD57TREEI, *LPDSD57TREEI;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRidChaves_4                           4L<br/>#define IDERRidTabela_5                           5L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Atualiza a tabela a Partir da Estrutura da Arvore<br/> *    Template ID:   D57TREEK<br/> *    Generated:     Mon Jun 07 15:46:17 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEK<br/>#define DATASTRUCTURE_D57TREEK<br/><br/>typedef struct tagDSD57TREEK<br/>{<br/>  ID                idChaves;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  int               nNumChaves;                          <br/>  JCHAR              szIdItemPai[11];                     <br/>  JCHAR              szIdItemFilho[11];                   <br/>  JCHAR              szIdTabela[11];                      <br/>  ID                idArvore;                            <br/>  JCHAR              szFuncao[61];                        <br/>} DSD57TREEK, *LPDSD57TREEK;<br/><br/>#define IDERRidChaves_2                           2L<br/>#define IDERRcCodigoErro_7                        7L<br/>#define IDERRszDescricaoErro_8                    8L<br/>#define IDERRnNumChaves_10                        10L<br/>#define IDERRszIdItemPai_12                       12L<br/>#define IDERRszIdItemFilho_15                     15L<br/>#define IDERRszIdTabela_16                        16L<br/>#define IDERRidArvore_18                          18L<br/>#define IDERRszFuncao_20                          20L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Insere Um Campo em Um Nodo da Arvore<br/> *    Template ID:   D57TREEL<br/> *    Generated:     Tue Jun 08 14:54:50 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEL<br/>#define DATASTRUCTURE_D57TREEL<br/><br/>typedef struct tagDSD57TREEL<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              szNomeCampo[21];                     <br/>  JCHAR              szDataItemCampo[11];                 <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              cChar;                               <br/>  JCHAR              szString[61];                        <br/>  int               nInteger;                            <br/>  JDEDATE           jdData;                              <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  JCHAR              szStringChave[61];                   <br/>  int               nIntegerChave;                       <br/>  JDEDATE           jdDataChave;                         <br/>  JCHAR              cInserePais;                         <br/>} DSD57TREEL, *LPDSD57TREEL;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRszNomeCampo_2                        2L<br/>#define IDERRszDataItemCampo_3                    3L<br/>#define IDERRmnMathNumeric_4                      4L<br/>#define IDERRcChar_5                              5L<br/>#define IDERRszString_6                           6L<br/>#define IDERRnInteger_7                           7L<br/>#define IDERRjdData_8                             8L<br/>#define IDERRcCodigoErro_9                        9L<br/>#define IDERRszDescricaoErro_10                   10L<br/>#define IDERRszDataItemChave_11                   11L<br/>#define IDERRmnMathNumericChave_12                12L<br/>#define IDERRcCharChave_13                        13L<br/>#define IDERRszStringChave_14                     14L<br/>#define IDERRnIntegerChave_15                     15L<br/>#define IDERRjdDataChave_16                       16L<br/>#define IDERRcInserePais_17                       17L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Atualiza o Campo de um Nodo da Arvore<br/> *    Template ID:   D57TREEM<br/> *    Generated:     Mon Jun 07 10:44:59 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEM<br/>#define DATASTRUCTURE_D57TREEM<br/><br/>typedef struct tagDSD57TREEM<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemCampo[11];                 <br/>  JCHAR              szNomeCampo[21];                     <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              cChar;                               <br/>  JCHAR              szString[61];                        <br/>  int               nInteger;                            <br/>  JDEDATE           jdData;                              <br/>  JCHAR              cAtualizarPais;                      <br/>  JCHAR              szFuncaoFormula[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  int               nIntegerChave;                       <br/>  JCHAR              szStringChave[61];                   <br/>  JDEDATE           jdDataChave;                         <br/>} DSD57TREEM, *LPDSD57TREEM;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRszDataItemCampo_4                    4L<br/>#define IDERRszNomeCampo_5                        5L<br/>#define IDERRmnMathNumeric_6                      6L<br/>#define IDERRcChar_7                              7L<br/>#define IDERRszString_8                           8L<br/>#define IDERRnInteger_9                           9L<br/>#define IDERRjdData_10                            10L<br/>#define IDERRcAtualizarPais_11                    11L<br/>#define IDERRszFuncaoFormula_12                   12L<br/>#define IDERRszDataItemChave_13                   13L<br/>#define IDERRmnMathNumericChave_14                14L<br/>#define IDERRcCharChave_15                        15L<br/>#define IDERRnIntegerChave_16                     16L<br/>#define IDERRszStringChave_17                     17L<br/>#define IDERRjdDataChave_18                       18L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Calcula o Valor do Campo a Ser Atualizado<br/> *    Template ID:   D57TREEN<br/> *    Generated:     Mon May 31 09:27:36 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEN<br/>#define DATASTRUCTURE_D57TREEN<br/><br/>typedef struct tagDSD57TREEN<br/>{<br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szNomeCampo[21];                     <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              cChar;                               <br/>  JCHAR              szString[61];                        <br/>  int               nInteger;                            <br/>  JDEDATE           jdData;                              <br/>  MATH_NUMERIC      mnMathNumericNovo;                   <br/>  JCHAR              cCharNovo;                           <br/>  JCHAR              szStringNovo[61];                    <br/>  int               nIntegerNovo;                        <br/>  JDEDATE           jdDataNovo;                          <br/>} DSD57TREEN, *LPDSD57TREEN;<br/><br/>#define IDERRcCodigoErro_2                        2L<br/>#define IDERRszDescricaoErro_3                    3L<br/>#define IDERRszNomeCampo_5                        5L<br/>#define IDERRmnMathNumeric_6                      6L<br/>#define IDERRcChar_7                              7L<br/>#define IDERRszString_8                           8L<br/>#define IDERRnInteger_9                           9L<br/>#define IDERRjdData_10                            10L<br/>#define IDERRmnMathNumericNovo_13                 13L<br/>#define IDERRcCharNovo_14                         14L<br/>#define IDERRszStringNovo_15                      15L<br/>#define IDERRnIntegerNovo_16                      16L<br/>#define IDERRjdDataNovo_17                        17L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Atualiza tabela a Partir de Nodo da Arvore<br/> *    Template ID:   D57TREEO<br/> *    Generated:     Mon Jun 07 16:39:11 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEO<br/>#define DATASTRUCTURE_D57TREEO<br/><br/>typedef struct tagDSD57TREEO<br/>{<br/>  ID                idChaves;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  int               nNumChaves;                          <br/>  JCHAR              szIdItemPai[11];                     <br/>  JCHAR              szIdItemFilho[11];                   <br/>  ID                idArvore;                            <br/>  MATH_NUMERIC      mnMathNumericPai;                    <br/>  JCHAR              cCharPai;                            <br/>  JCHAR              szStringPai[61];                     <br/>  int               nIntegerPai;                         <br/>  JDEDATE           jdDataPai;                           <br/>  MATH_NUMERIC      mnMathNumericFilho;                  <br/>  JCHAR              cCharFilho;                          <br/>  int               nIntegerFilho;                       <br/>  JCHAR              szStringFilho[61];                   <br/>  JDEDATE           jdDataFilho;                         <br/>} DSD57TREEO, *LPDSD57TREEO;<br/><br/>#define IDERRidChaves_2                           2L<br/>#define IDERRcCodigoErro_7                        7L<br/>#define IDERRszDescricaoErro_8                    8L<br/>#define IDERRnNumChaves_10                        10L<br/>#define IDERRszIdItemPai_12                       12L<br/>#define IDERRszIdItemFilho_15                     15L<br/>#define IDERRidArvore_18                          18L<br/>#define IDERRmnMathNumericPai_20                  20L<br/>#define IDERRcCharPai_21                          21L<br/>#define IDERRszStringPai_22                       22L<br/>#define IDERRnIntegerPai_23                       23L<br/>#define IDERRjdDataPai_24                         24L<br/>#define IDERRmnMathNumericFilho_25                25L<br/>#define IDERRcCharFilho_26                        26L<br/>#define IDERRnIntegerFilho_27                     27L<br/>#define IDERRszStringFilho_28                     28L<br/>#define IDERRjdDataFilho_29                       29L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Inclusão/Pesquisa de Campo Chave<br/> *    Template ID:   D57TREEP<br/> *    Generated:     Mon Jun 07 16:26:23 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEP<br/>#define DATASTRUCTURE_D57TREEP<br/><br/>typedef struct tagDSD57TREEP<br/>{<br/>  ID                idChaves;                            <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              szString[61];                        <br/>  JCHAR              cChar;                               <br/>  JDEDATE           jdData;                              <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  int               nNumChaves;                          <br/>  int               nNumChave;                           <br/>  JCHAR              szIdChave[11];                       <br/>} DSD57TREEP, *LPDSD57TREEP;<br/><br/>#define IDERRidChaves_2                           2L<br/>#define IDERRmnMathNumeric_3                      3L<br/>#define IDERRszString_4                           4L<br/>#define IDERRcChar_5                              5L<br/>#define IDERRjdData_6                             6L<br/>#define IDERRcCodigoErro_7                        7L<br/>#define IDERRszDescricaoErro_8                    8L<br/>#define IDERRnNumChaves_10                        10L<br/>#define IDERRnNumChave_11                         11L<br/>#define IDERRszIdChave_17                         17L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Insere Um Campo em Um Nodo da Arvore<br/> *    Template ID:   D57TREEQ<br/> *    Generated:     Mon Jun 07 16:43:42 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREEQ<br/>#define DATASTRUCTURE_D57TREEQ<br/><br/>typedef struct tagDSD57TREEQ<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              szNomeCampo[21];                     <br/>  JCHAR              szDataItemCampo[11];                 <br/>  MATH_NUMERIC      mnMathNumeric;                       <br/>  JCHAR              cChar;                               <br/>  JCHAR              szString[61];                        <br/>  int               nInteger;                            <br/>  JDEDATE           jdData;                              <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  JCHAR              szStringChave[61];                   <br/>  int               nIntegerChave;                       <br/>  JDEDATE           jdDataChave;                         <br/>} DSD57TREEQ, *LPDSD57TREEQ;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRszNomeCampo_2                        2L<br/>#define IDERRszDataItemCampo_3                    3L<br/>#define IDERRmnMathNumeric_4                      4L<br/>#define IDERRcChar_5                              5L<br/>#define IDERRszString_6                           6L<br/>#define IDERRnInteger_7                           7L<br/>#define IDERRjdData_8                             8L<br/>#define IDERRcCodigoErro_9                        9L<br/>#define IDERRszDescricaoErro_10                   10L<br/>#define IDERRszDataItemChave_11                   11L<br/>#define IDERRmnMathNumericChave_12                12L<br/>#define IDERRcCharChave_13                        13L<br/>#define IDERRszStringChave_14                     14L<br/>#define IDERRnIntegerChave_15                     15L<br/>#define IDERRjdDataChave_16                       16L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Busca Um Campo em Um Nodo da Arvore<br/> *    Template ID:   D57TREER<br/> *    Generated:     Mon Jun 07 17:04:48 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREER<br/>#define DATASTRUCTURE_D57TREER<br/><br/>typedef struct tagDSD57TREER<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  JCHAR              szStringChave[61];                   <br/>  int               nIntegerChave;                       <br/>  JDEDATE           jdDataChave;                         <br/>  MATH_NUMERIC      mnNumCampos;                         <br/>  int               nNumCampos;                          <br/>} DSD57TREER, *LPDSD57TREER;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_9                        9L<br/>#define IDERRszDescricaoErro_10                   10L<br/>#define IDERRszDataItemChave_11                   11L<br/>#define IDERRmnMathNumericChave_12                12L<br/>#define IDERRcCharChave_13                        13L<br/>#define IDERRszStringChave_14                     14L<br/>#define IDERRnIntegerChave_15                     15L<br/>#define IDERRjdDataChave_16                       16L<br/>#define IDERRmnNumCampos_17                       17L<br/>#define IDERRnNumCampos_18                        18L<br/><br/>#endif<br/>//<br/>/*****************************************<br/> * TYPEDEF for Data Structure<br/> *    Template Name: Retorno Campo do Nodo Indicado Pelo Indice<br/> *    Template ID:   D57TREES<br/> *    Generated:     Tue Jun 08 08:10:35 2010<br/> *<br/> * DO NOT EDIT THE FOLLOWING TYPEDEF<br/> *    To make modifications, use the OneWorld Data Structure<br/> *    Tool to Generate a revised version, and paste from<br/> *    the clipboard.<br/> *<br/> **************************************/<br/><br/>#ifndef DATASTRUCTURE_D57TREES<br/>#define DATASTRUCTURE_D57TREES<br/><br/>typedef struct tagDSD57TREES<br/>{<br/>  ID                idArvore;                            <br/>  JCHAR              cCodigoErro;                         <br/>  JCHAR              szDescricaoErro[61];                 <br/>  JCHAR              szDataItemChave[11];                 <br/>  MATH_NUMERIC      mnMathNumericChave;                  <br/>  JCHAR              cCharChave;                          <br/>  JCHAR              szStringChave[61];                   <br/>  int               nIntegerChave;                       <br/>  JDEDATE           jdDataChave;                         <br/>  int               nNumCampo;                           <br/>  MATH_NUMERIC      mnMathNumericCampo;                  <br/>  JCHAR              cCharCampo;                          <br/>  JCHAR              szStringCampo[61];                   <br/>  int               nIntegerCampo;                       <br/>  JDEDATE           jdDataCampo;                         <br/>  JCHAR              szDataItemCampo[11];                 <br/>  JCHAR              szNomeCampo[12];                     <br/>} DSD57TREES, *LPDSD57TREES;<br/><br/>#define IDERRidArvore_1                           1L<br/>#define IDERRcCodigoErro_9                        9L<br/>#define IDERRszDescricaoErro_10                   10L<br/>#define IDERRszDataItemChave_11                   11L<br/>#define IDERRmnMathNumericChave_12                12L<br/>#define IDERRcCharChave_13                        13L<br/>#define IDERRszStringChave_14                     14L<br/>#define IDERRnIntegerChave_15                     15L<br/>#define IDERRjdDataChave_16                       16L<br/>#define IDERRnNumCampo_20                         20L<br/>#define IDERRmnMathNumericCampo_21                21L<br/>#define IDERRcCharCampo_22                        22L<br/>#define IDERRszStringCampo_23                     23L<br/>#define IDERRnIntegerCampo_24                     24L<br/>#define IDERRjdDataCampo_25                       25L<br/>#define IDERRszDataItemCampo_26                   26L<br/>#define IDERRszNomeCampo_27                       27L<br/><br/>#endif<br/>//<br/>/*****************************************************************************<br/> * Source Preprocessor Definitions<br/> ****************************************************************************/<br/>#if defined (JDEBFRTN)<br/>	#undef JDEBFRTN<br/>#endif<br/><br/>#if defined (WIN32)<br/>	#if defined (WIN32)<br/>		#define JDEBFRTN(r) __declspec(dllexport) r<br/>	#else<br/>		#define JDEBFRTN(r) __declspec(dllimport) r<br/>	#endif<br/>#else<br/>	#define JDEBFRTN(r) r<br/>#endif<br/><br/>/*****************************************************************************<br/> * Business Function Prototypes<br/> ****************************************************************************/<br/>//funções para construção manual da arvore<br/>JDEBFRTN (ID) JDEBFWINAPI DeleteNodo                       (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEE lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI FinalizaArvore                   (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEB lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI InicializaArvore                 (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEA lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI InsereNodo                       (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEC lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PesquisaArvore                   (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEF lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI AtualizaNodoCampo                (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEM lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI InsereNodoCampo                  (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEL lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoCampo                    (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEQ lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoNumCampos                (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREER lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoCampoNum                 (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREES lpDS);<br/>//funções para contrução automatica da arvore<br/>JDEBFRTN (ID) JDEBFWINAPI AtualizaTabela                   (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEK lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI CarregaTabela                    (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEG lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PegaCampoTabela                  (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREED lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI InsereCampoChave                 (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEJ lpDS);<br/>JDEBFRTN (ID) JDEBFWINAPI PegaCampoChave                   (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEP lpDS);<br/>//<br/>/*****************************************************************************<br/> * Internal Function Prototypes<br/> ****************************************************************************/<br/>int I57TREE_CopiaValor (JCHAR *szItemDados, void **ValorDestino, void *ValorOrigem);<br/>int I57TREE_ComparaValor (JCHAR *szItemDados, void *Valor1, void *Valor2);<br/>void I57TREE_MontaSelectFilho (SELECTSTRUCT *lpSelect, int nNumChave, JCHAR *szIdTabela, JCHAR *szIdChave, void *Valor);<br/>//<br/>EstruturaArvore *I57TREE_CriarRaiz(JCHAR *szItemDados, Chave NovaChave);<br/>PNodoArvore I57TREE_CriarNovoNodo(JCHAR *szItemDados, Chave chave);<br/>BOOL I57TREE_InserirFilho(EstruturaArvore *Arvore, JCHAR *szItemDados, Chave NovaChave, Chave ChavePai);<br/>PNodoArvore I57TREE_BuscaNodo (JCHAR *szItemDados, SkipList *ss, Chave chave);<br/>void I57TREE_AtualizaArvoreNodo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, JCHAR cAtualizaPais, JCHAR *szItemDados, JCHAR *NomeCampo, JCHAR *Funcao, void *Valor, Chave chave, PNodoArvore Raiz);<br/>void I57TREE_PercorreArvore (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, HUSER hUser, ID IdChaves, ID IdArvore,  JCHAR *szItemDados, JCHAR *Funcao, PNodoArvore Raiz);<br/>//<br/>BOOL I57TREE_Empilha(JCHAR *szItemDados, struct Pilha *pilha, void *Data);<br/>void *I57TREE_DesEmpilha(JCHAR *szItemDados, struct Pilha *pilha);<br/>void I57TREE_IniciaPilha(struct Pilha *pilha);<br/>//<br/>int I57TREE_InsereArray (Data *Campos, Data item, int *nNumElementos, int *nNumAlocados);<br/>int I57TREE_PesquisaArray(Data *Campos, JCHAR *NomeCampo, int nNumElementos);<br/>int I57TREE_OrdenaArray(Data *Campos,  int nNumElementos);<br/>int ststring_cmp(const void *a, const void *b);<br/>//<br/>float I57TREE_frand();<br/>int I57TREE_random_level();<br/>SkipNodo* I57TREE_CriaNodo(int level, Chave Valor, PNodoArvore Link);<br/>SkipList*  I57TREE_Cria_SkipList(PNodoArvore Link);<br/>PNodoArvore I57TREE_PesquisaSkipList(SkipList* ss, Chave Valor_Busca);<br/>void I57TREE_insert(SkipList* ss, Chave Valor, PNodoArvore Link);<br/>void I57TREE_delete(SkipList* ss, Chave Valor, PNodoArvore Link);<br/>//<br/>#endif    /* __B57TREE_H */<br/><br/></pre><BR/><pre><div class='dstrmembers'><B>Source File: b57tree.c</B><BR></div>#include &ltjde.h&gt<br/><br/>#define b57tree_c<br/><br/><br/>/*****************************************************************************<br/> *    Source File:  b57tree<br/> *<br/> *    Description:  Implementação de Arvore Source File<br/> *<br/> *        History:<br/> *          Date        Programmer  SAR# - Description<br/> *          ----------  ----------  -------------------------------------------<br/> *   Author 19/05/10                Unknown  - Created  <br/> *<br/> * Copyright (c) J.D. Edwards World Source Company, 1996<br/> *<br/> * This unpublished material is proprietary to J.D. Edwards World Source Company.<br/> * All rights reserved.  The methods and techniques described herein are<br/> * considered trade secrets and/or confidential.  Reproduction or<br/> * distribution, in whole or in part, is forbidden except by express<br/> * written permission of J.D. Edwards World Source Company.<br/> ****************************************************************************/<br/>/**************************************************************************<br/> * Notes:<br/> *<br/> **************************************************************************/<br/><br/>#include &ltb57tree.h&gt<br/><br/><br/><br/>/**************************************************************************<br/> *  Business Function:  DeleteNodo<br/> *<br/> *        Description:  Delta Nodo da Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEE        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI DeleteNodo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEE lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER						 hUser					   = (HUSER)NULL;<br/>    PNodoArvore                  Arvore                    = NULL;<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEE)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro),(const JCHAR *)(_J("Sem Erros")));<br/>	if (lpDS-&gtidArvore != 0)  {<br/>		Arvore = (PNodoArvore)jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>	} else {<br/>		//<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro),(const JCHAR *)(_J("Id da Arvore esta Nulo!!!")));<br/>		//<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  FinalizaArvore<br/> *<br/> *        Description:  Finaliza a Estrutura de Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEB        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI FinalizaArvore (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEB lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER						 hUser					   = (HUSER)NULL;<br/>    SELECTSTRUCT                 *lpSelect                 = (SELECTSTRUCT *)NULL; // Ponteiro para as chaves da tabela<br/><br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEB)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro),(const JCHAR *)(_J("Sem Erros")));<br/>    //====================================================================//<br/>    //            Libera a Memoria Usada Pela Arvore                      //<br/>    //====================================================================//<br/>    lpSelect = (SELECTSTRUCT *)jdeRetrieveDataPtr(hUser, (unsigned long)(lpDS-&gtidChaves));<br/>  	if (lpSelect != (LPSELECT) NULL)<br/>	{<br/>		jdeFree((void *) lpSelect);<br/>	}<br/>	jdeRemoveDataPtr(hUser, lpDS-&gtidChaves);<br/>	//<br/>    jdeRemoveDataPtr(hUser, lpDS-&gtidArvore);<br/>	//<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  InicializaArvore<br/> *<br/> *        Description:  Inicializa a Estrutura de Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEA        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI InicializaArvore (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEA lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                        idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER					  hUser						= (HUSER)NULL;<br/>    EstruturaArvore           Arvore;<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEA)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro),(const JCHAR *)(_J("Sem Erros")));<br/>	//====================================================================//<br/>	//                Cria uma nova estrutura de arvore                   //<br/>	//====================================================================//<br/>    //<br/>	// Arvore = I57TREE_CriarRaiz(lpDS-&gtszIdItemPai, ); //Insere o Nodo Pai que vai ser Zero;<br/>	//====================================================================//<br/>	//        Armazena a estrutura recem criada para o usuario            //<br/>	//====================================================================//<br/>	//lpDS-&gtidArvore = (ID)jdeStoreDataPtr(hUser, (EstruturaArvore *)Arvore);<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    if(hUser != (HUSER)NULL)<br/>    {<br/>       JDB_FreeBhvr(hUser);<br/>    }<br/>    //<br/>    return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  InsereNodo<br/> *<br/> *        Description:  Insere Nodo na Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEC        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI InsereNodo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEC lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER		             	 hUser			           = (HUSER)NULL;   <br/>    //PNodoArvore                  Arvore                    = NULL; // Estrutura da Arvore<br/>    //PNodoArvore                  NovoNodo                  = NULL; // Novo nodo a ser inserido na arvore<br/>    //PNodoArvore                  Raiz                      = NULL; // O nodo Raiz vai assumir o nodo passado na função como pai<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>	if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEC)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //====================================================================//<br/>	//                  Carrego a Arvore da memoria                       // <br/>    //====================================================================//<br/>	/*if (lpDS-&gtidArvore != 0 ) {<br/>		Arvore = (PNodoArvore)jdeRetrieveDataPtr(hUser, (unsigned long)lpDS-&gtidArvore);  <br/>		//<br/>	    PNodoArvore NovoNodo; // Nodo filho a ser inserido<br/>        PNodoArvore Raiz = I57TREE_BuscaNodo(lpDS-&gtChavePai, Arvore);<br/>	    //<br/>        if (!Raiz) {<br/>			lpDS-&gtcCodigoErro = 'S';<br/>			strcpy((char *)lpDS-&gtszDescricaoErro. (const char *)("Não conseguiu pegar o nodo raiz"));<br/>			return (ER_ERROR);<br/>		}<br/>	    //<br/>        NovoNodo = I57TREE_CriarNovoNodo(lpDS-&gtNovaChave); // Cria o novo nodo (filho) a ser inserido<br/>	    //<br/>        NovoNodo-&gtUltimoFilho = NULL;                // Zera o nodo com ultimo filho do novo nodo <br/>		NovoNodo-&gtUltimoIrmao = Raiz-&gtUltimoFilho;   // Aponta o ultimo irmão do novo nodo para o ultimo filho do nodo pai<br/>		//<br/>		Raiz-&gtUltimoFilho = NovoNodo;                // Aponta o ultimo filho do pai para o novo nodo<br/>		//<br/>	} else {<br/>		lpDS-&gtcCodigoErro = 'S';<br/>		strcpy((char *)lpDS-&gtszDescricaoErro. (const char *)("ID da Arvore Zerado!"));<br/>	}*/<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    if(hUser != (HUSER)NULL)<br/>    {<br/>       JDB_FreeBhvr(hUser);<br/>    }<br/>    //<br/>    return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  PesquisaArvore<br/> *<br/> *        Description:  Pesquisa Nodo na Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEF        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI PesquisaArvore (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEF lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER						 hUser				       = (HUSER)NULL;   <br/>	EstruturaArvore              *Arvore                   = NULL; // Estrutura da Arvore<br/>    PNodoArvore                  AuxArvore                 = NULL;<br/>    Chave                        chave                     = NULL;<br/>	DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEF)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //====================================================================//<br/>	//                  Carrego a Arvore da memoria                       // <br/>    //====================================================================//<br/>	if (lpDS-&gtidArvore != 0 ) {<br/>		Arvore = jdeRetrieveDataPtr(hUser, (unsigned long)lpDS-&gtidArvore);  <br/>		//<br/>		lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>		//<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         :  chave = malloc(sizeof(JCHAR)); memcpy(chave, &lpDS-&gtcCharChave, sizeof(JCHAR)); break;// Char<br/>			case EVDT_STRING       :  chave = malloc(sizeof(lpDS-&gtszStringChave)); jdeStrncpyTerminate((JCHAR *)chave, lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave)); break;// String<br/>			case EVDT_MATH_NUMERIC :  chave = malloc(sizeof(MATH_NUMERIC)); MathCopy(chave, &lpDS-&gtmnMathNumericChave); break;// Math Numeric<br/>			case EVDT_INT          :  chave = malloc(sizeof(int)); memcpy(chave, &lpDS-&gtnIntegerChave, sizeof(int)); break;// integer<br/>			case EVDT_JDEDATE      :  chave = malloc(sizeof(JDEDATE)); memcpy (chave, &lpDS-&gtjdDataChave, sizeof(JDEDATE)); break;// Date<br/>		}<br/><br/>        jdeDDDestroy(lpItemDados);<br/><br/>		//<br/>        AuxArvore = I57TREE_BuscaNodo(lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);// Busco o nodo indicado pela Chave de pesquisa<br/>		if (AuxArvore != NULL){<br/>			lpDS-&gtcCodigoErro = _J('N'); <br/>			jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Registro foi Encontarado!!!")));<br/>		} else {<br/>			lpDS-&gtcCodigoErro = _J('S'); <br/>			jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Não Achou o registro na Arvore!!!")));<br/>		}<br/>		//<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S'); <br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("ID da Arvore Zerado!")));<br/>	}   <br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    if(hUser != (HUSER)NULL)<br/>    {<br/>       JDB_FreeBhvr(hUser);<br/>    }<br/>    //<br/>    return (ER_SUCCESS);<br/>}<br/><br/>/**************************************************************************<br/> *  Business Function:  CarregaTabela<br/> *<br/> *        Description:  Cria a Estrutura da Arvore a Partir de Uma Tabela<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEG        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI CarregaTabela (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEG lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>    HUSER			 hUser			   = (HUSER)NULL;   <br/>	EstruturaArvore              *Arvore                   = NULL;<br/>    Chave                        ItemPai                   = NULL;<br/>	Chave                        ItemFilho                 = NULL;<br/>    //<br/>    HREQUEST                     hTabela                   = (HREQUEST)NULL; // Handle para a Tabela a ser carregada<br/>    SELECTSTRUCT                 *lpSelect                 = (SELECTSTRUCT *)NULL; // Ponteiro para as chaves da tabela<br/>    JDECM_RESULT                 lResultado                = 0;<br/>    struct Pilha                 stPilha;<br/>    //<br/>    DSD57TREEI                   ds57TREEI                 = {0};<br/>    DBREF                        dbItem;<br/>    LPVOID                       lpItem;<br/>    //<br/>    long                         lNumRegistros             = 0;<br/>	BOOL                         bTemErro                  = FALSE;<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEG)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>	//Abre a tabela que vai popular a arvore<br/>    lResultado = JDB_OpenTable(hUser, lpDS-&gtszIdTabela, 0, NULL, 0, NULL, &hTabela); <br/>	if (lResultado == JDEDB_PASSED) {<br/>		//começa o processamento para montar a arvore, crio a raiz da arvore<br/>		lpSelect = (SELECTSTRUCT *)jdeRetrieveDataPtr(hUser, (unsigned long)(lpDS-&gtidChaves));<br/>		Arvore = I57TREE_CriarRaiz(lpDS-&gtszIdItemPai, lpSelect[lpDS-&gtnNumChaves-1].lpValue); //Insere o Nodo Pai que vai ser Zero;<br/>		//Inicializa a Pilha<br/>	    I57TREE_IniciaPilha(&stPilha);<br/><br/>        ds57TREEI.idTabela = (ID)jdeStoreDataPtr(hUser, hTabela);<br/>		ds57TREEI.idArvore = (ID)jdeStoreDataPtr(hUser, Arvore);<br/><br/>        while (ItemFilho != NULL || lNumRegistros == 0) {<br/>			bTemErro = FALSE;<br/>			lNumRegistros++;<br/>			//		<br/>			if (lpSelect != NULL) {<br/>				//Adiciona a chave filho<br/>				if (lNumRegistros &gt 1) {<br/>					I57TREE_MontaSelectFilho (lpSelect, lpDS-&gtnNumChaves-1, lpDS-&gtszIdTabela, lpDS-&gtszIdItemPai, ItemFilho);<br/>				}<br/>				//Seta as chaves que serão usadas para pesquisar a tabela<br/>				JDB_ClearSelection(hTabela);<br/>				lResultado = JDB_SetSelection(hTabela, lpSelect, (unsigned short)(lpDS-&gtnNumChaves), JDEDB_SET_REPLACE); <br/>				if (lResultado != JDEDB_PASSED) <br/>				{<br/>					//Processa o Erro, guarda na tabela de log<br/>					bTemErro = TRUE;<br/>					JDB_CloseTable(hTabela);<br/>					lpDS-&gtcCodigoErro = 'S';<br/>					strcpy((char *)(lpDS-&gtszDescricaoErro), (const char *)("Não conseguiu setar a seleção de dados!"));<br/>					return ER_ERROR;<br/>				}<br/>				//executa o select<br/>				lResultado = JDB_SelectKeyed(hTabela, 0, NULL, 0); <br/>				if (lResultado != JDEDB_PASSED) <br/>				{   <br/>					//Processa o Erro, guarda na tabela de log<br/>					bTemErro = TRUE;<br/>					JDB_CloseTable(hTabela);<br/>					lpDS-&gtcCodigoErro = 'S';<br/>					strcpy((char *)(lpDS-&gtszDescricaoErro), (const char *)("Não achou dados!"));<br/>					return ER_ERROR; <br/>				}<br/>				//Pega Todos os filhos, processa eles e coloca na pilha<br/>				while (JDB_Fetch(hTabela, NULL, FALSE) == JDEDB_PASSED) {<br/>					//<br/>					//Pego o Valor do Campo Filho<br/>					jdeNIDcpy (dbItem.szTable, lpDS-&gtszIdTabela);<br/>					dbItem. idInstance = 0;<br/>					jdeNIDcpy (dbItem.szDict, lpDS-&gtszIdItemFilho);<br/>					ItemFilho = JDB_GetTableColValue(hTabela, dbItem);<br/>                    //Pego o Valor do Campo Pai<br/>					jdeNIDcpy (dbItem.szTable, lpDS-&gtszIdTabela);<br/>					dbItem. idInstance = 0;<br/>					jdeNIDcpy (dbItem.szDict, lpDS-&gtszIdItemPai);<br/>					ItemPai = JDB_GetTableColValue(hTabela, dbItem);<br/>                    //<br/>					//Coloca os Nodos Filhos na Arvore<br/>					I57TREE_InserirFilho(Arvore, lpDS-&gtszIdItemPai, ItemFilho, ItemPai);<br/>					//Coloca os Nodos Filhos na Pilha <br/>					I57TREE_Empilha(lpDS-&gtszIdItemPai, &stPilha, ItemFilho);<br/>					//Armazena o estado atual da tabela (posição em que se encontra(cursor))<br/>					if (!jdeIsBlankOrNull(lpDS-&gtszCriaCampos))<br/>					{<br/>						//<br/>						//Chama função customizada para criação dos campos de cada nodo da arvore<br/>						//A estrutura de dados utilizada para os parametros vai ser sempre a mesma<br/>					    idJDEDBReturn =  jdeCallObject(lpDS-&gtszCriaCampos, NULL,<br/>								                       lpBhvrCom,lpVoid,(LPVOID)&ds57TREEI,<br/>											           (CALLMAP *)NULL,(int)0,(JCHAR *)NULL,<br/>								                       (JCHAR *)NULL,(int)0);<br/>	<br/>					    if (idJDEDBReturn == ER_SUCCESS) {<br/>							//					<br/>							//Arvore = (EstruturaArvore *)jdeRetrieveDataPtr(hUser, ds57TREEI.idArvore);<br/>							//I57TREE_OrdenaArray(Arvore-&gtCampos, Arvore-&gtnNumElementos);<br/>							//<br/>						} else {<br/>							//<br/>							//<br/>						}<br/>						//<br/>						//libera a memoria que havia sido alocada antes de chamar a função customizada<br/>						//jdeRemoveDataPtr(hUser, ds57TREEI.idTabela);<br/>						//jdeRemoveDataPtr(hUser, ds57TREEI.idArvore);<br/>						//<br/>					}<br/>				}<br/>				//			<br/>			} else {<br/>				//<br/>				lpDS-&gtcCodigoErro = _J('S');<br/>				jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Não conseguiu recuperar as chaves de pesquisa!")));<br/>				//<br/>			}<br/>			//<br/>			ItemFilho = I57TREE_DesEmpilha(lpDS-&gtszIdItemPai ,&stPilha);<br/>		}<br/>		if (lNumRegistros == 0) {<br/>			lpDS-&gtcCodigoErro = _J('S');<br/>			jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Arvore com 0 Registros!")));<br/>		};<br/>		//<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Abrindo a Tabela!")));<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    //lpDS-&gtidArvore = jdeStoreDataPtr(hUser, Arvore);<br/>    lpDS-&gtidArvore = ds57TREEI.idArvore;<br/>    JDB_CloseTable(hTabela);<br/>    return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  InsereCampoChave<br/> *        Description:  Insere Campo de Pesquisa Para Tabela<br/> *************************************************************************/<br/>//<br/>JDEBFRTN (ID) JDEBFWINAPI InsereCampoChave (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEJ lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    SELECTSTRUCT                 *lpSelect                 = (SELECTSTRUCT *)NULL; // Ponteiro para as chaves da tabela<br/>	DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    ==  (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEJ)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>    if (lpDS-&gtidChaves == 0){<br/>		//<br/>		lpSelect = jdeAlloc(COMMON_POOL,lpDS-&gtnNumChaves * sizeof (SELECTSTRUCT), MEM_ZEROINIT); <br/>		//<br/>	} else {<br/>		//<br/>        lpSelect = (SELECTSTRUCT *)jdeRetrieveDataPtr(hUser, (unsigned long)(lpDS-&gtidChaves));<br/>		//<br/>	};<br/>    //<br/>	jdeNIDcpy(lpSelect[lpDS-&gtnNumChave].Item1.szDict, lpDS-&gtszIdChave);<br/>	jdeNIDcpy(lpSelect[lpDS-&gtnNumChave].Item1.szTable, lpDS-&gtszIdTabela);<br/>	lpSelect[lpDS-&gtnNumChave].Item1.idInstance = 0;<br/>	jdeNIDcpy(lpSelect[lpDS-&gtnNumChave].Item2.szDict, _J(""));<br/>	jdeNIDcpy(lpSelect[lpDS-&gtnNumChave].Item2.szTable, _J(""));<br/>	lpSelect[lpDS-&gtnNumChave].Item1.idInstance = 0;<br/>    //<br/>	lpItemDados = jdeDDCreate(NULL, lpDS-&gtszIdChave, 0, NULL);<br/>	if (lpItemDados-&gtwStatus == 0) <br/>    {<br/>    //<br/>		if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) {<br/>			//<br/>			lpSelect[lpDS-&gtnNumChave].lpValue = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>			MathCopy((MATH_NUMERIC *) lpSelect[lpDS-&gtnNumChave].lpValue, &lpDS-&gtmnMathNumeric);<br/>			//<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>			//<br/>			lpSelect[lpDS-&gtnNumChave].lpValue = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszString), MEM_ZEROINIT);<br/>			jdeStrncpyTerminate (lpSelect[lpDS-&gtnNumChave].lpValue, lpDS-&gtszString, DIM(lpDS-&gtszString));<br/><br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>			//<br/>    		lpSelect[lpDS-&gtnNumChave].lpValue = &lpDS-&gtcChar;<br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>			//<br/>    		lpSelect[lpDS-&gtnNumChave].lpValue = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>			memcpy((void *) (lpSelect[lpDS-&gtnNumChave].lpValue), (const void *)(&lpDS-&gtjdData), sizeof(JDEDATE));<br/>   		    //<br/>		}<br/>		//<br/>		lpSelect[lpDS-&gtnNumChave].nAndOr = JDEDB_ANDOR_AND;<br/>		lpSelect[lpDS-&gtnNumChave].nCmp   = JDEDB_CMP_EQ;<br/>		lpSelect[lpDS-&gtnNumChave].nValues = 1;<br/>		lpDS-&gtidChaves = (ID)jdeStoreDataPtr(hUser, (void *)lpSelect);<br/>		//<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Não encontro o Item de Dados no Dicionario")));<br/>	};<br/>    jdeDDDestroy(lpItemDados);<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  PegaCampoChave<br/> *        Description:  Pega Campo de Chave usado pela tabela<br/> *************************************************************************/<br/>//<br/>JDEBFRTN (ID) JDEBFWINAPI PegaCampoChave (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEP lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    SELECTSTRUCT                 *lpSelect                 = (SELECTSTRUCT *)NULL; // Ponteiro para as chaves da tabela<br/>	DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    ==  (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREEP)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>    if (lpDS-&gtidChaves == 0){<br/>		//<br/>		lpSelect = jdeAlloc(COMMON_POOL,lpDS-&gtnNumChaves * sizeof (SELECTSTRUCT), MEM_ZEROINIT); <br/>		//<br/>	} else {<br/>		//<br/>        lpSelect = (SELECTSTRUCT *)jdeRetrieveDataPtr(hUser, (unsigned long)(lpDS-&gtidChaves));<br/>		//<br/>	};<br/>    //<br/>	lpItemDados = jdeDDCreate(NULL, lpDS-&gtszIdChave, 0, NULL);<br/>	if (lpItemDados-&gtwStatus == 0) <br/>    {<br/>    //<br/>		if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) {<br/>			//<br/>			MathCopy(&lpDS-&gtmnMathNumeric, (MATH_NUMERIC *) lpSelect[lpDS-&gtnNumChave].lpValue);<br/>			//<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>			//<br/>			jdeStrncpyTerminate (lpDS-&gtszString, lpSelect[lpDS-&gtnNumChave].lpValue, DIM(lpDS-&gtszString));<br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>			//<br/>			lpDS-&gtcChar = *(JCHAR *)lpSelect[lpDS-&gtnNumChave].lpValue;<br/>  		    //<br/>		} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>			//<br/>			memcpy((void *)(&lpDS-&gtjdData), (const void *)(lpSelect[lpDS-&gtnNumChave].lpValue), sizeof(JDEDATE));<br/>   		    //<br/>		}<br/>		//<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Não encontro o Item de Dados no Dicionario")));<br/>	};<br/>    jdeDDDestroy(lpItemDados);<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  PegaCampoTabela<br/> *<br/> *        Description:  Pega um Campo da Tabela<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREED        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI PegaCampoTabela (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREED lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>	HREQUEST                     hTabela                   = (HREQUEST)NULL; // Handle para a Tabela a ser carregada<br/>	//<br/>   /************************************************************************<br/>    * Declare pointers<br/>    ************************************************************************/<br/><br/>	DSDDINFO        *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados	<br/>   /************************************************************************<br/>    * Declare structures<br/>    ************************************************************************/<br/><br/>	DBREF			dbItem;<br/><br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL) ||<br/>       (lpDS      == (LPDSD57TREED)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidTabela != 0) {<br/>		hTabela = (HREQUEST)jdeRetrieveDataPtr(hUser, lpDS-&gtidTabela);<br/>     	//Pego o Valor do Campo Filho<br/>	 	jdeNIDcpy (dbItem.szTable, lpDS-&gtszIdTabela);<br/>	    dbItem. idInstance = 0;<br/>        jdeNIDcpy (dbItem.szDict, lpDS-&gtszCampo);<br/>		//<br/>		lpItemDados = jdeDDCreate(NULL, lpDS-&gtszCampo, 0, NULL);<br/>		//<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         :  lpDS-&gtcChar = *(JCHAR *)JDB_GetTableColValue(hTabela, dbItem); break;// Char<br/>			case EVDT_STRING       :  jdeStrncpyTerminate(lpDS-&gtszString, (JCHAR *)JDB_GetTableColValue(hTabela, dbItem), sizeof(lpDS-&gtszString)); break;// String<br/>			case EVDT_MATH_NUMERIC :  MathCopy(&lpDS-&gtmnMathNumeric, (MATH_NUMERIC *)JDB_GetTableColValue(hTabela, dbItem)); break;// Math Numeric<br/>			case EVDT_INT          :  lpDS-&gtnInteger = (int)JDB_GetTableColValue(hTabela, dbItem); break;// integer<br/>			case EVDT_JDEDATE      :  memcpy (&lpDS-&gtjdData, (JDEDATE *)JDB_GetTableColValue(hTabela, dbItem), sizeof(JDEDATE)); break;// Date<br/>		}<br/>        jdeDDDestroy(lpItemDados);<br/>        //<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Handle de Tabela Vazio!")));<br/>	}	<br/>    //<br/><br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    if(hUser != (HUSER)NULL)<br/>    {<br/>       JDB_FreeBhvr(hUser);<br/>    }<br/>    //<br/>    return (ER_SUCCESS);<br/>	//<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  AtualizaTabela<br/> *<br/> *        Description:  Atualiza a Tabela de Acordo com a Estrutura da Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEK        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI AtualizaTabela (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEK lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    EstruturaArvore				 *Arvore				   = NULL;<br/>	ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>	if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>        (lpVoid    == (LPVOID)    NULL) ||<br/>        (lpDS      == (LPDSD57TREEK)	NULL))<br/>	{<br/>	  jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>	  return ER_ERROR;<br/>	}<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		Arvore = jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		if (Arvore-&gtArvore != NULL) {<br/>			//<br/>			I57TREE_PercorreArvore(lpBhvrCom, lpVoid, hUser, lpDS-&gtidChaves, lpDS-&gtidArvore, lpDS-&gtszIdItemPai, lpDS-&gtszFuncao, Arvore-&gtArvore);<br/>			//<br/>		} else {<br/>			lpDS-&gtcCodigoErro = _J('S');<br/>			jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Arvore Vazia !!!")));<br/>		}<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("ID Arvore nulo!!!")));<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>   return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  AtualizaNodoCampo<br/> *<br/> *        Description:  Atualiza um Determinado Campo de um Nodo da Arvore<br/> *<br/> *         Parameters:<br/> *           LPBHVRCOM           lpBhvrCom    Business Function Communications<br/> *           LPVOID              lpVoid       Void Parameter - DO NOT USE!<br/> *           LPDSD57TREEM        lpDS         Parameter Data Structure Pointer  <br/> *<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI AtualizaNodoCampo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEM lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    EstruturaArvore              *Arvore                   = NULL;<br/>	PNodoArvore                  AuxArvore                 = NULL;<br/>	Chave                        chave                     = NULL;<br/>    DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	void                         *Valor                    = NULL;<br/>    //<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>        (lpVoid    == (LPVOID)    NULL) ||<br/>        (lpDS      == (LPDSD57TREEM)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		//<br/>		Arvore = jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		//<br/>		lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>		//<br/>		switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>			case EVDT_CHAR         :  chave = malloc(sizeof(JCHAR)); memcpy(chave, &lpDS-&gtcCharChave, sizeof(JCHAR)); break;// Char<br/>			case EVDT_STRING       :  chave = malloc(sizeof(lpDS-&gtszStringChave)); jdeStrncpyTerminate((JCHAR *)chave, lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave)); break;// String<br/>			case EVDT_MATH_NUMERIC :  chave = malloc(sizeof(MATH_NUMERIC)); MathCopy(chave, &lpDS-&gtmnMathNumericChave); break;// Math Numeric<br/>			case EVDT_INT          :  chave = malloc(sizeof(int)); memcpy(chave, &lpDS-&gtnIntegerChave, sizeof(int)); break;// integer<br/>			case EVDT_JDEDATE      :  chave = malloc(sizeof(JDEDATE)); memcpy (chave, &lpDS-&gtjdDataChave, sizeof(JDEDATE)); break;// Date<br/>		}<br/>        jdeDDDestroy(lpItemDados);<br/>		//<br/>		AuxArvore = I57TREE_BuscaNodo(lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);// Busco o nodo indicado pela Chave de pesquisa<br/>		if (AuxArvore != NULL) {<br/>			//<br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemCampo, 0, NULL);<br/>			//<br/>			switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) <br/>            {<br/>				case EVDT_CHAR         : Valor = &lpDS-&gtcChar;<br/>									break;// Char<br/>				case EVDT_STRING       : Valor = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszString), MEM_ZEROINIT);<br/>										 jdeStrncpyTerminate (Valor, lpDS-&gtszString, DIM(lpDS-&gtszString)); <br/>									break;// String<br/>				case EVDT_MATH_NUMERIC : Valor = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>										 MathCopy((MATH_NUMERIC *) Valor, &lpDS-&gtmnMathNumeric);<br/>									break;// Math Numeric<br/>				case EVDT_INT          : Valor = jdeAlloc(COMMON_POOL,sizeof(int), MEM_ZEROINIT);<br/>										 Valor = &lpDS-&gtnInteger;<br/>									break;// integer<br/>				case EVDT_JDEDATE      : Valor = jdeAlloc(COMMON_POOL,sizeof(JDEDATE), MEM_ZEROINIT);<br/>										 memcpy((JDEDATE *) Valor, &lpDS-&gtjdData, sizeof(JDEDATE));<br/>									break;// Date<br/>			}<br/><br/>            //<br/>            jdeDDDestroy(lpItemDados);<br/>		    I57TREE_AtualizaArvoreNodo (lpBhvrCom, lpVoid, lpDS-&gtcAtualizarPais, lpDS-&gtszDataItemCampo, lpDS-&gtszNomeCampo, lpDS-&gtszFuncaoFormula, Valor, AuxArvore-&gtchave, AuxArvore);<br/>            //<br/><br/>		} else <br/>        {<br/><br/>			lpDS-&gtcCodigoErro = _J('S');<br/>			jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Não Achou o Registro na Arvore!!!")));<br/><br/>		}<br/>		//<br/>    } else {<br/>		//<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Recuperando a Arvore da Memoria!!!")));<br/>		return ER_ERROR;<br/>		//<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/><br/>    return (ER_SUCCESS);<br/>}<br/><br/><br/>/**************************************************************************<br/> *  Business Function:  InsereNodoCampo<br/> *        Description:  Insere Campos em um Determinado Nodo da Arvore<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI InsereNodoCampo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEL lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    EstruturaArvore              *Arvore;<br/>	PNodoArvore                  AuxArvore                 = NULL;<br/>	Data                         *Campos                   = NULL;<br/>	Data                         Item                      = {0};<br/>	Chave                        chave                     = NULL;<br/>    DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	JCHAR                         cContinua                 = _J('S');<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57TREEL)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		//<br/>		Arvore = (EstruturaArvore *)jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		if (Arvore-&gtArvore != NULL)<br/>		{<br/>			// <br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) {<br/>			//<br/>				 if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>					 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>					 MathCopy((MATH_NUMERIC *) chave, &lpDS-&gtmnMathNumericChave);<br/>					 //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>				 	 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszString), MEM_ZEROINIT);<br/>					 jdeStrncpyTerminate (chave, (JCHAR *)lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave));<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 	 //<br/>					 chave = &lpDS-&gtcChar;<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>					 //<br/>    				 chave = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>					 memcpy((void *) (chave), &lpDS-&gtjdDataChave, sizeof(JDEDATE));<br/>		   		     //<br/>				 }       <br/>				//<br/>			}<br/>			//<br/>            jdeDDDestroy(lpItemDados);<br/>			AuxArvore = I57TREE_BuscaNodo (lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);<br/>			Campos = AuxArvore-&gtCampos;<br/>			//<br/>			jdeStrncpyTerminate ((JCHAR *)Item.Nome, (const JCHAR*)lpDS-&gtszNomeCampo, DIM(Item.Nome));<br/>		    // <br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemCampo, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) <br/>            {<br/>				//<br/>			    while ((AuxArvore-&gtPai != NULL) && (cContinua == _J('S'))) {<br/>				//<br/>				    if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>						 //<br/>						 Item.Valor = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>						 MathCopy((MATH_NUMERIC *) Item.Valor, &lpDS-&gtmnMathNumeric);<br/>						 //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>					 	 //<br/>						 Item.Valor = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszString), MEM_ZEROINIT);<br/>						 jdeStrncpyTerminate (Item.Valor, (JCHAR *)lpDS-&gtszString, DIM(lpDS-&gtszString));<br/>	  					 //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 		 //<br/>						 Item.Valor = malloc(sizeof(JCHAR));<br/>						 Item.Valor = &lpDS-&gtcChar;<br/>	  				     //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>						 //<br/>						 Item.Valor = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>						 memcpy((void *) (Item.Valor), &lpDS-&gtjdData, sizeof(JDEDATE));<br/>						 //<br/>					}       <br/>					//<br/>					I57TREE_InsereArray(Campos, Item, &AuxArvore-&gtnNumElementos, &AuxArvore-&gtnNumAlocados);<br/>					//<br/>					if (lpDS-&gtcInserePais == _J('S')) {<br/>						//<br/>						AuxArvore = AuxArvore-&gtPai;<br/>						Campos = AuxArvore-&gtCampos;<br/>						//<br/>					} else {<br/>						//<br/>						cContinua = _J('N');<br/>						//<br/>					}<br/>				}<br/>			}<br/>            jdeDDDestroy(lpItemDados);<br/>			//<br/>			//lpDS-&gtidArvore = (ID)jdeStoreDataPtr(hUser, Arvore);<br/>		}<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Carregando a Arvore!")));<br/>		return ER_ERROR;<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  PegaNodoCampo<br/> *        Description:  Pega Campo de um Determinado Nodo da Arvore<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoCampo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREEQ lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    EstruturaArvore              *Arvore;<br/>	PNodoArvore                  AuxArvore                 = NULL;<br/>	Data                         *Campos                   = NULL;<br/>	Chave                        chave                     = NULL;<br/>    DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	int                          Posicao                   = 0;<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57TREEQ)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		//<br/>		Arvore = (EstruturaArvore *)jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		if (Arvore-&gtArvore != NULL)<br/>		{<br/>			// <br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) <br/>            {<br/>			//<br/>				 if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>					 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>					 MathCopy((MATH_NUMERIC *) chave, &lpDS-&gtmnMathNumericChave);<br/>					 //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>				 	 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszString), MEM_ZEROINIT);<br/>					 jdeStrncpyTerminate (chave, (JCHAR *)lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave));<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 	 //<br/>					 chave = &lpDS-&gtcChar;<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>					 //<br/>    				 chave = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>					 memcpy((void *) (chave), &lpDS-&gtjdDataChave, sizeof(JDEDATE));<br/>		   		     //<br/>				 }       <br/>				//<br/>			}<br/>			//<br/>            jdeDDDestroy(lpItemDados);<br/>			AuxArvore = I57TREE_BuscaNodo (lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);<br/>			Campos = AuxArvore-&gtCampos;<br/>			Posicao = I57TREE_PesquisaArray(Campos, lpDS-&gtszNomeCampo, AuxArvore-&gtnNumElementos);<br/>			if (Posicao &gt= 0) {<br/>				//<br/>				lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemCampo, 0, NULL);<br/>				if (lpItemDados-&gtwStatus == 0) <br/>                {<br/>					//<br/>				    if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>						 //<br/>						 MathCopy(&lpDS-&gtmnMathNumeric, (MATH_NUMERIC *)Campos[Posicao].Valor);<br/>						 //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>					 	 //<br/>						 jdeStrncpyTerminate (lpDS-&gtszString, (JCHAR *)Campos[Posicao].Valor, DIM(lpDS-&gtszString));<br/>	  					 //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 		 //<br/>						 lpDS-&gtcChar = *(JCHAR *)Campos[Posicao].Valor;<br/>	  				     //<br/>					} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>						 //<br/>						 memcpy(&lpDS-&gtjdData, Campos[Posicao].Valor, sizeof(JDEDATE));<br/>						 //<br/>					}       <br/>				}<br/>                jdeDDDestroy(lpItemDados);<br/>				//<br/>			} else {<br/>				//<br/>				//<br/>			}<br/>			//<br/>		}<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Carregando a Arvore!")));<br/>		return ER_ERROR;<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  PegaNodoNumCampos<br/> *        Description:  Pega Numero de Campos de um Determinado Nodo<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoNumCampos (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREER lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    EstruturaArvore              *Arvore;<br/>	PNodoArvore                  AuxArvore                 = NULL;<br/>	Chave                        chave                     = NULL;<br/>    DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57TREER)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		//<br/>		Arvore = (EstruturaArvore *)jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		if (Arvore-&gtArvore != NULL)<br/>		{<br/>			// <br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) <br/>            {<br/>			//<br/>				 if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>					 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>					 MathCopy((MATH_NUMERIC *) chave, &lpDS-&gtmnMathNumericChave);<br/>					 //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>				 	 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszStringChave), MEM_ZEROINIT);<br/>					 jdeStrncpyTerminate (chave, (JCHAR *)lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave));<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 	 //<br/>					 chave = &lpDS-&gtcCharChave;<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>					 //<br/>    				 chave = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>					 memcpy((void *) (chave), &lpDS-&gtjdDataChave, sizeof(JDEDATE));<br/>		   		     //<br/>				 }       <br/>				//<br/>			}<br/>            jdeDDDestroy(lpItemDados);<br/>			//<br/>			AuxArvore = I57TREE_BuscaNodo (lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);<br/>			if (AuxArvore != NULL) {<br/>				lpDS-&gtnNumCampos = AuxArvore-&gtnNumElementos;<br/>				IntToMathNumeric(AuxArvore-&gtnNumElementos, &lpDS-&gtmnNumCampos);<br/>			} else {<br/>				lpDS-&gtcCodigoErro = _J('S');<br/>				jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Registro Não encontrado na Arvore !!!")));<br/>			}<br/>			//<br/>		}<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Carregando a Arvore!")));<br/>		return ER_ERROR;<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    return (ER_SUCCESS);<br/>}<br/>//<br/>/**************************************************************************<br/> *  Business Function:  PegaNodoCampoNum<br/> *        Description:  Pega Campo do Nodo Indicado Pelo Indice<br/> *************************************************************************/<br/><br/>JDEBFRTN (ID) JDEBFWINAPI PegaNodoCampoNum (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, LPDSD57TREES lpDS)  <br/>{<br/>   /************************************************************************<br/>    *  Variable declarations<br/>    ************************************************************************/<br/>    ID                           idJDEDBReturn             = ER_SUCCESS;<br/>	HUSER						 hUser					   = (HUSER)NULL;   <br/>    EstruturaArvore              *Arvore;<br/>	PNodoArvore                  AuxArvore                 = NULL;<br/>	Chave                        chave                     = NULL;<br/>    DSDDINFO                     *lpItemDados              = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>   /************************************************************************<br/>    * Check for NULL pointers<br/>    ************************************************************************/<br/>    if ((lpBhvrCom == (LPBHVRCOM) NULL) ||<br/>       (lpVoid    == (LPVOID)    NULL)  ||<br/>       (lpDS      == (LPDSD57TREES)	NULL))<br/>    {<br/>      jdeErrorSet (lpBhvrCom, lpVoid, (ID) 0, _J("4363"), (LPVOID) NULL);<br/>      return ER_ERROR;<br/>    }<br/>    //<br/>    idJDEDBReturn = JDB_InitBhvr(lpBhvrCom, &hUser, (JCHAR *) NULL,<br/> 	                             JDEDB_COMMIT_AUTO);<br/>    //<br/> 	if (idJDEDBReturn == JDEDB_FAILED)<br/>	{<br/>      jdeSetGBRError ( lpBhvrCom, lpVoid, (ID)0, _J("3143"));<br/>      return ER_ERROR;<br/>	}<br/>    //<br/>   /************************************************************************<br/>    * Main Processing<br/>    ************************************************************************/<br/>	//inicializa as Variaveis de Erro<br/>	lpDS-&gtcCodigoErro = _J('N');<br/>    jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Sem Erros")));<br/>    //<br/>	if (lpDS-&gtidArvore != 0) {<br/>		//<br/>		Arvore = (EstruturaArvore *)jdeRetrieveDataPtr(hUser, lpDS-&gtidArvore);<br/>		if (Arvore-&gtArvore != NULL)<br/>		{<br/>			// <br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemChave, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) <br/>            {<br/>			//<br/>				 if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>					 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>					 MathCopy((MATH_NUMERIC *) chave, &lpDS-&gtmnMathNumericChave);<br/>					 //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>				 	 //<br/>					 chave = jdeAlloc(COMMON_POOL,sizeof(lpDS-&gtszStringChave), MEM_ZEROINIT);<br/>					 jdeStrncpyTerminate (chave, (JCHAR *)lpDS-&gtszStringChave, DIM(lpDS-&gtszStringChave));<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 	 //<br/>					 chave = &lpDS-&gtcCharChave;<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>					 //<br/>    				 chave = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>					 memcpy((void *) (chave), &lpDS-&gtjdDataChave, sizeof(JDEDATE));<br/>		   		     //<br/>				 }       <br/>				//<br/>			}<br/>            jdeDDDestroy(lpItemDados);<br/>			//<br/>			AuxArvore = I57TREE_BuscaNodo (lpDS-&gtszDataItemChave, Arvore-&gtIndice, chave);<br/>			//<br/>			jdeStrncpyTerminate (lpDS-&gtszNomeCampo, (JCHAR *)AuxArvore-&gtCampos[lpDS-&gtnNumCampo].Nome, DIM(lpDS-&gtszNomeCampo));<br/>			//<br/>			lpItemDados = jdeDDCreate(NULL, lpDS-&gtszDataItemCampo, 0, NULL);<br/>			if (lpItemDados-&gtwStatus == 0) <br/>            {<br/>			//<br/>				 if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>					 //<br/>					 MathCopy(&lpDS-&gtmnMathNumericCampo, (MATH_NUMERIC *)AuxArvore-&gtCampos[lpDS-&gtnNumCampo].Valor);<br/>					 //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>				 	 //<br/>					 jdeStrncpyTerminate (lpDS-&gtszStringCampo, (JCHAR *)AuxArvore-&gtCampos[lpDS-&gtnNumCampo].Valor, DIM(lpDS-&gtszStringCampo));<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				 	 //<br/>					 lpDS-&gtcCharCampo = *(JCHAR *)AuxArvore-&gtCampos[lpDS-&gtnNumCampo].Valor;<br/>  				     //<br/>				 } else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>					 //<br/>					 memcpy(&lpDS-&gtjdDataChave, AuxArvore-&gtCampos[lpDS-&gtnNumCampo].Valor, sizeof(JDEDATE));<br/>		   		     //<br/>				 }       <br/>				//<br/>			}<br/>            jdeDDDestroy(lpItemDados);<br/>			//<br/>		}<br/>	} else {<br/>		lpDS-&gtcCodigoErro = _J('S');<br/>		jdeStrcpy((JCHAR *)(lpDS-&gtszDescricaoErro), (const JCHAR *)(_J("Erro Carregando a Arvore!")));<br/>		return ER_ERROR;<br/>	}<br/>   /************************************************************************<br/>    * Function Clean Up<br/>    ************************************************************************/<br/>    return (ER_SUCCESS);<br/>}<br/>//==============================================================//<br/>//                Funções Internas Auxiliares                   //<br/>//==============================================================//<br/>int I57TREE_CopiaValor (JCHAR *szItemDados, void **ValorDestino, void *ValorOrigem) {<br/>	//<br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>	//<br/>	switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>		case EVDT_CHAR         : *ValorDestino = malloc(sizeof(JCHAR)); memcpy(*ValorDestino, ValorOrigem, sizeof(JCHAR)); break;// Char<br/>		case EVDT_STRING       : *ValorDestino = malloc((jdeStrlen((const JCHAR *)(ValorOrigem))*sizeof(JCHAR))); jdeStrncpyTerminate((JCHAR *)ValorDestino, (JCHAR *)ValorOrigem, (jdeStrlen((const JCHAR *)(ValorOrigem))*sizeof(JCHAR))); break;// String<br/>		case EVDT_MATH_NUMERIC : *ValorDestino = malloc(sizeof(MATH_NUMERIC)); memcpy(*ValorDestino, ValorOrigem, sizeof(MATH_NUMERIC));break;// Math Numeric<br/>		case EVDT_INT          : *ValorDestino = malloc(sizeof(int)); memcpy(*ValorDestino, ValorOrigem, sizeof(int)); break;// integer<br/>		case EVDT_JDEDATE      : *ValorDestino = malloc(sizeof(JDEDATE)); memcpy(*ValorDestino, ValorOrigem, sizeof(JDEDATE));break;// Date<br/>	}<br/>	//<br/>    jdeDDDestroy(lpItemDados);<br/>	return 2;<br/>}<br/>//<br/>int I57TREE_ComparaValor (JCHAR *szItemDados, void *Valor1, void *Valor2) {<br/>	//<br/>	DSDDINFO  *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>	//<br/>    lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>	//<br/>	switch(lpItemDados-&gtlpGlobalCol-&gtidEverestType) {<br/>		case EVDT_CHAR         :	if ( *(JCHAR *)Valor1 &gt *(JCHAR *)Valor2 )  {<br/>			                           return 1;  <br/>								 } else if ( *(JCHAR *)Valor1 &lt *(JCHAR *)Valor2 ) {<br/>									   return -1;<br/>								 } else if ( *(JCHAR *)Valor1 == *(JCHAR *)Valor2 ) {<br/>									   return 0;<br/>								 }<br/>							break;// Char<br/>		case EVDT_STRING       :	return jdeStrcmp((JCHAR *)(Valor1), (JCHAR *)(Valor2));<br/>								break;// String<br/>		case EVDT_MATH_NUMERIC :	return MathCompare ((MATH_NUMERIC *)(Valor1), (MATH_NUMERIC *)(Valor2));<br/>								break;// Math Numeric<br/>		case EVDT_INT          :	 if ((int)(Valor1) &lt (int)Valor2) {<br/>										return 1;<br/>									} else if ((int)(Valor1) &gt (int)(Valor2)) {<br/>										return -1;<br/>									} else if ((int)(Valor1) == (int)(Valor2)) {<br/>										return 0;<br/>									}<br/>								break;// integer<br/>		case EVDT_JDEDATE      :	return JDEDATECmp((JDEDATE *)(Valor1), (JDEDATE *)(Valor2));<br/>								break;// Date<br/>	}<br/>    jdeDDDestroy(lpItemDados);<br/>	//<br/>	return 2;<br/>}<br/>//<br/>void I57TREE_MontaSelectFilho (SELECTSTRUCT *lpSelect, int nNumChave, JCHAR *szIdTabela, JCHAR *szIdChave, void *Valor) {<br/>	 //<br/>	 jdeNIDcpy(lpSelect[nNumChave].Item1.szDict, szIdChave);<br/>	 jdeNIDcpy(lpSelect[nNumChave].Item1.szTable, szIdTabela);<br/>	 lpSelect[nNumChave].Item1.idInstance = 0;<br/>	 jdeNIDcpy(lpSelect[nNumChave].Item2.szDict, _J(""));<br/>	 jdeNIDcpy(lpSelect[nNumChave].Item2.szTable, _J(""));<br/>	 lpSelect[nNumChave].Item1.idInstance = 0;<br/>	 lpSelect[nNumChave].lpValue = Valor;<br/>	 lpSelect[nNumChave].nAndOr = JDEDB_ANDOR_AND;<br/>	 lpSelect[nNumChave].nCmp   = JDEDB_CMP_EQ;<br/>	 lpSelect[nNumChave].nValues = 1;<br/>	 //<br/>}<br/>//<br/>//==============================================================//<br/>//   Funções Internas para trabalhar com a estrutura da arvore  //<br/>//==============================================================//<br/>//<br/>void I57TREE_AtualizaArvoreNodo (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, JCHAR cAtualizaPais, JCHAR *szItemDados, JCHAR *NomeCampo, JCHAR *Funcao, void *Valor, Chave chave, PNodoArvore Raiz) {<br/>  JCHAR cContinua = _J('S');<br/>  ID idJDEDBReturn;<br/>  DSD57TREEN ds57TREEN; <br/>  PNodoArvore Aux;<br/>  Data Item = {0};<br/>  DSDDINFO *lpItemDados = (DSDDINFO *)NULL; //Ponteiro para o item no dicionario de dados<br/>  int Posicao = 0;<br/>  //<br/>  if (Raiz == NULL) return;<br/>  //<br/>  while (Raiz != NULL && cContinua == _J('S')) {<br/>	 Posicao = I57TREE_PesquisaArray(Raiz-&gtCampos, NomeCampo, Raiz-&gtnNumElementos);<br/>	 //<br/>	 if (Posicao &gt= 0) {<br/>		//popula os campos atuais<br/>		jdeStrcpy(ds57TREEN.szNomeCampo, NomeCampo);<br/>		MathCopy(&ds57TREEN.mnMathNumeric, (MATH_NUMERIC *)Raiz-&gtCampos[Posicao].Valor);<br/>		MathCopy(&ds57TREEN.mnMathNumericNovo, (MATH_NUMERIC *)Valor);<br/>		//Chama a função que faz a atualização, ela recebe como parametros os valores atuais do campo<br/>		idJDEDBReturn =  jdeCallObject(Funcao, NULL,<br/>		         	                     lpBhvrCom,lpVoid,(LPVOID)&ds57TREEN,<br/>							             (CALLMAP *)NULL,(int)0,(JCHAR *)NULL,<br/>				                         (JCHAR *)NULL,(int)0);    <br/>		  //<br/>		  if (idJDEDBReturn == ER_SUCCESS) {<br/>			  MathCopy(Raiz-&gtCampos[Posicao].Valor, &ds57TREEN.mnMathNumeric);<br/>		  }<br/>		  //<br/>	  } else {<br/>		  jdeStrcpy(Item.Nome, NomeCampo);<br/>		  //<br/>		  lpItemDados = jdeDDCreate(NULL, szItemDados, 0, NULL);<br/>		  //	<br/>		  if (lpItemDados-&gtwStatus == 0) <br/>          {<br/>			//<br/>			if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_MATH_NUMERIC) { <br/>				//<br/>				Item.Valor = jdeAlloc(COMMON_POOL,sizeof(MATH_NUMERIC), MEM_ZEROINIT);<br/>				MathCopy((MATH_NUMERIC *) Item.Valor, (MATH_NUMERIC *)Valor);<br/>				//<br/>			} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_STRING) {<br/>	 			//<br/>				Item.Valor = jdeAlloc(COMMON_POOL,sizeof(EVDT_STRING), MEM_ZEROINIT);<br/>				jdeStrncpyTerminate (Item.Valor, (JCHAR *)Valor, (jdeStrlen((const JCHAR *)(Valor))*sizeof(JCHAR)));<br/>		  		//<br/>			} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_CHAR) {<br/>				//<br/>				Item.Valor = malloc(sizeof(JCHAR));<br/>				Item.Valor = Valor;<br/>	  			//<br/>			} else if (lpItemDados-&gtlpGlobalCol-&gtidEverestType == EVDT_JDEDATE) {<br/>				//<br/>				Item.Valor = jdeAlloc(COMMON_POOL,sizeof(EVDT_JDEDATE), MEM_ZEROINIT);<br/>				memcpy((void *) (Item.Valor), Valor, sizeof(JDEDATE));<br/>				//<br/>			}                   <br/>		  }	<br/>          jdeDDDestroy(lpItemDados);<br/>		  I57TREE_InsereArray(Raiz-&gtCampos, Item, &Raiz-&gtnNumElementos, &Raiz-&gtnNumAlocados);<br/>	};<br/>	//<br/>	if (cAtualizaPais == _J('S')) { Raiz = Raiz-&gtPai; }<br/>	else { cContinua = _J('N'); }	<br/>	//<br/>  }<br/>  //<br/>}<br/><br/>//<br/>PNodoArvore I57TREE_BuscaNodo (JCHAR *szItemDados, SkipList *ss, Chave chave) {<br/>	PNodoArvore Aux;<br/>	//<br/>	Aux = I57TREE_PesquisaSkipList(ss, chave);<br/>	//<br/>    return Aux;<br/>	//<br/>}<br/>//<br/>EstruturaArvore *I57TREE_CriarRaiz(JCHAR *szItemDados, Chave NovaChave){<br/>	EstruturaArvore *Aux = malloc(sizeof(EstruturaArvore));<br/>	//<br/>	Aux-&gtArvore = I57TREE_CriarNovoNodo(szItemDados, NovaChave);<br/>	Aux-&gtIndice = I57TREE_Cria_SkipList(Aux-&gtArvore);<br/>	I57TREE_insert(Aux-&gtIndice, NovaChave, Aux-&gtArvore);<br/>    //<br/>    return Aux;<br/>} <br/>//<br/>PNodoArvore I57TREE_CriarNovoNodo(JCHAR *szItemDados, Chave chave){<br/>   //<br/>   PNodoArvore NovoNodo = (PNodoArvore)malloc(sizeof(NodoArvore));<br/>   //<br/>   NovoNodo-&gtUltimoFilho = NULL;<br/>   NovoNodo-&gtUltimoIrmao = NULL;<br/>   NovoNodo-&gtPai         = NULL;<br/>   NovoNodo-&gtCampos      = malloc(sizeof(Data)*200);<br/>   NovoNodo-&gtnNumElementos = 0;<br/>   NovoNodo-&gtnNumAlocados  = 200;<br/>   NovoNodo-&gtnNumFilhos    = 0;<br/>   jdeStrncpyTerminate(NovoNodo-&gtszItemDadosChave, szItemDados, DIM(NovoNodo-&gtszItemDadosChave));<br/>   I57TREE_CopiaValor(szItemDados ,&NovoNodo-&gtchave, chave);<br/>   return NovoNodo;<br/>}<br/>//<br/>BOOL I57TREE_InserirFilho(EstruturaArvore *Arvore, JCHAR *szItemDados, Chave NovaChave, Chave ChavePai){<br/>	 //<br/>	 PNodoArvore NovoNodo;<br/>	 PNodoArvore pai = I57TREE_BuscaNodo(szItemDados, Arvore-&gtIndice, ChavePai);<br/>	 //<br/>	 if (!pai) return FALSE;<br/>	 //<br/>	 NovoNodo = I57TREE_CriarNovoNodo(szItemDados, NovaChave);<br/>	 //<br/>	 NovoNodo-&gtPai         = pai;<br/>	 NovoNodo-&gtUltimoFilho = NULL;<br/>	 NovoNodo-&gtUltimoIrmao = pai-&gtUltimoFilho;<br/>	 //<br/>	 pai-&gtUltimoFilho = NovoNodo;<br/>	 pai-&gtnNumFilhos++;<br/>	 //<br/>	 //insere no indice<br/>	 I57TREE_insert(Arvore-&gtIndice, NovaChave, NovoNodo);<br/>     return TRUE;<br/>}<br/>//<br/>void I57TREE_PercorreArvore (LPBHVRCOM lpBhvrCom, LPVOID lpVoid, HUSER hUser, ID IdChaves,ID IdArvore,  JCHAR *szItemDados, JCHAR *Funcao, PNodoArvore Raiz){<br/>	ID idJDEDBReturn;<br/>	PNodoArvore filhos;<br/>	DSD57TREEO  ds57TREEO;<br/>    //<br/>	if (Raiz == NULL) return;<br/>	//<br/>	//Chama função que faz atualização na tabela <br/>	ds57TREEO.idArvore = IdArvore;<br/>	ds57TREEO.idChaves = IdChaves;<br/>	if (Raiz-&gtPai != NULL) { MathCopy(&ds57TREEO.mnMathNumericPai, (MATH_NUMERIC *)Raiz-&gtPai-&gtchave); }<br/>	else { ZeroMathNumeric(&ds57TREEO.mnMathNumericPai); }<br/>	MathCopy(&ds57TREEO.mnMathNumericFilho, (MATH_NUMERIC *)Raiz-&gtchave);<br/>	idJDEDBReturn =  jdeCallObject(Funcao, NULL,<br/>		                           lpBhvrCom,lpVoid,(LPVOID)&ds57TREEO,<br/>					               (CALLMAP *)NULL,(int)0,(JCHAR *)NULL,<br/>		                           (JCHAR *)NULL,(int)0);    <br/>    //<br/>	if (idJDEDBReturn == ER_SUCCESS) {<br/>	}<br/>	//<br/>	filhos = Raiz-&gtUltimoFilho;<br/>	//<br/>	if (filhos == NULL) return;<br/>	//<br/>	while (filhos != NULL){<br/>	    I57TREE_PercorreArvore(lpBhvrCom, lpVoid, hUser, IdChaves, IdArvore, szItemDados, Funcao, filhos);<br/>	    filhos = filhos-&gtUltimoIrmao;<br/>	}<br/>	//<br/>}<br/>//<br/>//========================================================//<br/>//         Funções Internas para Manter a Pilha           //<br/>//========================================================//<br/>//<br/>BOOL I57TREE_Empilha(JCHAR *szItemDados, struct Pilha *pilha, void *Data)<br/>{<br/>	pilha-&gtNodos = malloc(sizeof(struct NodoPilha));<br/>	if(pilha-&gtNodos == NULL)<br/>	{<br/>		return FALSE;<br/>	}<br/>    I57TREE_CopiaValor(szItemDados ,&pilha-&gtNodos-&gtData, Data);<br/>	pilha-&gtNodos-&gtLink = pilha-&gtCabeca;<br/>	pilha-&gtCabeca= pilha-&gtNodos;<br/>	return TRUE;<br/>}<br/>//<br/>void *I57TREE_DesEmpilha(JCHAR *szItemDados, struct Pilha *pilha){<br/>	void *temp = NULL;<br/>	if(pilha-&gtCabeca!=NULL){<br/>		I57TREE_CopiaValor(szItemDados ,&temp, pilha-&gtCabeca-&gtData);<br/>		pilha-&gtNodos = pilha-&gtCabeca;<br/>		pilha-&gtCabeca = pilha-&gtCabeca-&gtLink;<br/>		free(pilha-&gtNodos);<br/>	}<br/>	return temp;<br/>}<br/>//<br/>void I57TREE_IniciaPilha(struct Pilha *pilha)<br/>{<br/>	pilha-&gtCabeca = NULL;<br/>	pilha-&gtNodos = NULL;<br/>}<br/>//<br/>//===============================================================//<br/>//  Funções Internas para Manter o array de campos da cada nodo  //<br/>//===============================================================//<br/>//<br/>int I57TREE_InsereArray (Data *Campos, Data item, int *nNumElementos, int *nNumAlocados)<br/>{<br/>	void *_tmp;<br/>	int Posicao;<br/>	//<br/>	Posicao = I57TREE_PesquisaArray(Campos, item.Nome, *nNumElementos);<br/>	//<br/>	if (Posicao &lt 0) {<br/>		if(*nNumElementos == *nNumAlocados) { 		<br/>			//<br/>			if (*nNumAlocados == 0) {<br/>				*nNumAlocados = 12; <br/>			} else {<br/>				*nNumAlocados += 2; <br/>			}<br/>			//		<br/>			_tmp = realloc(Campos, *nNumAlocados * sizeof(Data));<br/>			//		<br/>			if (!_tmp)<br/>			{ <br/>				return(-1);  //Não conseguiu alocar memoria para o array<br/>			}<br/>			//		<br/>			Campos = (Data *)_tmp;	<br/>			//<br/>		}	<br/>		//memcpy(&Campos[*nNumElementos], &item, sizeof(Data));<br/>		jdeStrcpy(Campos[*nNumElementos].Nome, item.Nome);<br/>		Campos[*nNumElementos].Valor = malloc(sizeof(MATH_NUMERIC));<br/>		memcpy(Campos[*nNumElementos].Valor, item.Valor, sizeof(MATH_NUMERIC));<br/>		*nNumElementos += 1;<br/>	//<br/>	}<br/>	return *nNumElementos;<br/>}<br/>//executa pesquisa binaria em cima do array, o mesmo precisa estar ordenado<br/>/*int I57TREE_PesquisaArray (Data *Campos, char *NomeCampo, int nNumElementos) {<br/>	Data *posicao;<br/>	Data item;<br/>	int  Posicao;<br/>	strcpy(item.Nome, NomeCampo); <br/>	posicao = (Data *)bsearch(&item, Campos, nNumElementos, sizeof(Data), (int (__cdecl *)(const void *, const void *))(ststring_cmp));<br/>	Posicao = posicao - &Campos[0];<br/>	return Posicao;<br/>}*/<br/>int I57TREE_PesquisaArray (Data *Campos, JCHAR *NomeCampo, int nNumElementos) {<br/>	int  Posicao;<br/>	for (Posicao = 0; Posicao &lt nNumElementos; Posicao++) {<br/>		if (jdeStrcmp(jdeStripBlanks(Campos[Posicao].Nome), jdeStripBlanks(NomeCampo)) == 0) return Posicao;<br/>	}<br/>	return -1;<br/>}<br/><br/>//<br/>int ststring_cmp(const void *a, const void *b) {//função usada para comparar a chave <br/>    Data *ia = (Data *)a;<br/>    Data *ib = (Data *)b;<br/>	return jdeStrcmp(ia-&gtNome, ib-&gtNome);<br/>}<br/>//<br/>int I57TREE_OrdenaArray (Data *Campos, int nNumElementos) {<br/>	//<br/>	qsort(Campos, nNumElementos, sizeof(Data), (int (__cdecl *)(const void *, const void *))ststring_cmp);    <br/>	//<br/>	return 0;<br/>}<br/>//<br/>float I57TREE_frand() {<br/>	return (float) rand() / RAND_MAX;<br/>}<br/>//<br/>int I57TREE_random_level() {<br/>    static int first = 1;<br/>    int lvl = 0;<br/><br/>    if(first) {<br/>        srand( (unsigned)time( NULL ) );<br/>        first = 0;<br/>    }<br/><br/>    while(I57TREE_frand() &lt P && lvl &lt MAX_LEVEL)<br/>	lvl++;<br/><br/>    return lvl;<br/>}<br/>//<br/>SkipNodo* I57TREE_CriaNodo(int level, Chave Valor, PNodoArvore Link){<br/>	SkipNodo* sn = (SkipNodo*)malloc(sizeof(SkipNodo));<br/>    //<br/>    sn-&gtforward = (SkipNodo**)calloc(level + 1, sizeof(SkipNodo *));<br/>    sn-&gtchave = malloc(sizeof(JCHAR[16]));<br/>    jdeStrcpy((JCHAR *)sn-&gtchave, Valor);<br/>	sn-&gtLink = Link;<br/>    return sn;<br/>}<br/>//<br/>SkipList*  I57TREE_Cria_SkipList(PNodoArvore Link){<br/>    int i;<br/>    SkipList* ss = (SkipList*)malloc(sizeof(SkipList));<br/>    <br/>    ss-&gtheader = I57TREE_CriaNodo(MAX_LEVEL, _J("0"), Link);<br/>    for (i = 0; i &lt= MAX_LEVEL; i++) {<br/>        ss-&gtheader-&gtforward[i] = ss-&gtheader;<br/>    }<br/><br/>    ss-&gtlevel = 0;<br/>    return ss;<br/>}<br/>//<br/>PNodoArvore I57TREE_PesquisaSkipList(SkipList* ss, Chave Valor_Busca){<br/><br/>    int i;<br/>    SkipNodo* x = ss-&gtheader;<br/>    for(i = ss-&gtlevel; i &gt= 0; i--) {<br/>        while(x-&gtforward[i] != ss-&gtheader && jdeStrcmp(x-&gtforward[i]-&gtchave, Valor_Busca) &lt 0) {<br/>            x = x-&gtforward[i];<br/>        }<br/>    }<br/>    x = x-&gtforward[0];<br/><br/>    if(x != NULL && jdeStrcmp(x-&gtchave, Valor_Busca) == 0)<br/>		return x-&gtLink;        <br/>    return NULL;   <br/>}<br/>//<br/>void I57TREE_insert(SkipList* ss, Chave Valor, PNodoArvore Link){<br/>    int i;<br/>    SkipNodo* x = ss-&gtheader;	<br/>    SkipNodo* update[MAX_LEVEL + 1];<br/>    memset(update, 0, MAX_LEVEL + 1);<br/><br/><br/>    for(i = ss-&gtlevel; i &gt= 0; i--) {<br/>        while(x-&gtforward[i] != ss-&gtheader && jdeStrcmp(x-&gtforward[i]-&gtchave, Valor) &lt 0) {<br/>            x = x-&gtforward[i];<br/>        }<br/>        update[i] = x; <br/>    }<br/><br/>    x = x-&gtforward[0];<br/><br/>    if(x == NULL || jdeStrcmp(x-&gtchave, Valor) != 0) {<br/><br/>        int lvl = I57TREE_random_level();<br/>  <br/>        if(lvl &gt ss-&gtlevel) {<br/><br/>	        for(i = ss-&gtlevel + 1; i &lt= lvl; i++) {<br/>	            update[i] = ss-&gtheader;<br/>	        }<br/><br/>	        ss-&gtlevel = lvl;<br/><br/>	    }<br/><br/>         x = I57TREE_CriaNodo(lvl, Valor, Link);<br/>	     for(i = 0; i &lt= lvl; i++) {<br/><br/>	        x-&gtforward[i] = update[i]-&gtforward[i];<br/>	        update[i]-&gtforward[i] = x;<br/><br/>	    }<br/><br/>    }<br/>}<br/>//<br/>void I57TREE_delete(SkipList* ss, Chave value, PNodoArvore Link){<br/>    int i;<br/>    SkipNodo* x = ss-&gtheader;	<br/>    SkipNodo* update[MAX_LEVEL + 1];<br/>    memset(update, 0, MAX_LEVEL + 1);<br/>    //<br/>    for(i = ss-&gtlevel; i &gt= 0; i--) {<br/>        while(x-&gtforward[i] != NULL && jdeStrcmp(x-&gtforward[i]-&gtchave, value) &lt 0) {<br/>            x = x-&gtforward[i];<br/>        }<br/>        update[i] = x; <br/>    }<br/>	//<br/>    x = x-&gtforward[0];<br/>    //<br/>    if(jdeStrcmp(x-&gtchave, value) == 0) {<br/>        for(i = 0; i &lt= ss-&gtlevel; i++) {<br/>		   if(update[i]-&gtforward[i] != x) break;<br/>		   update[i]-&gtforward[i] = x-&gtforward[i];<br/>		}<br/>		//<br/>		free(x);<br/>		//<br/>		while(ss-&gtlevel &gt 0 && ss-&gtheader-&gtforward[ss-&gtlevel] == NULL) {<br/>		    ss-&gtlevel--;<br/>		}<br/>	    //<br/>    }<br/>	//<br/>}<br/>//<br/></pre></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [AtualizaTabela]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEK - Atualiza a tabela a Partir da Estrutura da Arvore           </B><BR>BF idChaves [GENLNG]<BR>BF cCodigoErro [EV02]<BR>BF szDescricaoErro [BRD60]<BR>BF nNumChaves [CIP]<BR>BF szIdItemPai [DTAI]<BR>BF szIdItemFilho [DTAI]<BR>BF szIdTabela [LRSTN]<BR>BF idArvore [GENLNG]<BR>BF szFuncao [MD]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [CarregaTabela]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEG - Monta Arvore a Partir de Tabela                             </B><BR>BF idChaves [GENLNG]<BR>BF cCodigoErro [EV02]<BR>BF szDescricaoErro [BRD60]<BR>BF nNumChaves [CIP]<BR>BF szIdItemPai [DTAI]<BR>BF szIdItemFilho [DTAI]<BR>BF szIdTabela [LRSTN]<BR>BF szCriaCampos [MD]<BR>BF idArvore [GENLNG]<BR>BF cTipoPaiFilho [EV01]<BR>BF mnMathNumericRaiz [CNTF]<BR>BF cCharRaiz [EV01]<BR>BF szStringRaiz [BRD60]<BR>BF nIntegerRaiz [CIP]<BR>BF jdDataRaiz [UPMJ]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [DeleteNodo]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEE - Deleta Nodo da Arvore                                       </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [FinalizaArvore]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEB - Finaliza Estrutura de Arvore                                </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF idChaves [GENLNG]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [InicializaArvore]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEA - Inicializa Estrutura de Arvore                              </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [InsereCampoChave]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEJ - Inclusão/Pesquisa de Campo Chave                            </B><BR>BF idChaves [GENLNG]<BR>BF mnMathNumeric [VLRTOTLI]<BR>BF szString [BRD60]<BR>BF cChar [EV01]<BR>BF jdData [UPMJ]<BR>BF cCodigoErro [EV02]<BR>BF szDescricaoErro [BRD60]<BR>BF nNumChaves [CIP]<BR>BF nNumChave [CIP]<BR>BF szIdTabela [LRSTN]<BR>BF szIdChave [DTAI]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [InsereNodo]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEC - Insere na  Estrutura de Arvore                              </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [InsereNodoCampo]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEL - Insere Um Campo em Um Nodo da Arvore                        </B><BR>BF idArvore [GENLNG]<BR>BF szNomeCampo [AA20]<BR>BF szDataItemCampo [DTAI]<BR>BF mnMathNumeric [CNTF]<BR>BF cChar [EV01]<BR>BF szString [BRD60]<BR>BF nInteger [CIP]<BR>BF jdData [UPMJ]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF szStringChave [BRD60]<BR>BF nIntegerChave [CIP]<BR>BF jdDataChave [UPMJ]<BR>BF cInserePais [EV01]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PegaCampoChave]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEP - Pesquisa de Campo Chave                                     </B><BR>BF idChaves [GENLNG]<BR>BF mnMathNumeric [VLRTOTLI]<BR>BF szString [BRD60]<BR>BF cChar [EV01]<BR>BF jdData [UPMJ]<BR>BF cCodigoErro [EV02]<BR>BF szDescricaoErro [BRD60]<BR>BF nNumChaves [CIP]<BR>BF nNumChave [CIP]<BR>BF szIdChave [DTAI]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PegaCampoTabela]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREED - Busca Campo do Registro Sendo Processado da Tabela          </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF idTabela [GENLNG]<BR>BF szCampo [DTAI]<BR>BF mnMathNumeric [CNTF]<BR>BF szString [BRD60]<BR>BF cChar [EV01]<BR>BF jdData [UPMJ]<BR>BF nInteger [CIP]<BR>BF szIdTabela [DTAI]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PegaNodoCampo]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEQ - Busca Um Campo em Um Nodo da Arvore                         </B><BR>BF idArvore [GENLNG]<BR>BF szNomeCampo [AA20]<BR>BF szDataItemCampo [DTAI]<BR>BF mnMathNumeric [CNTF]<BR>BF cChar [EV01]<BR>BF szString [BRD60]<BR>BF nInteger [CIP]<BR>BF jdData [UPMJ]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF szStringChave [BRD60]<BR>BF nIntegerChave [CIP]<BR>BF jdDataChave [UPMJ]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PegaNodoCampoNum]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREES - Retorno Campo do Nodo Indicado Pelo Indice                  </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF szStringChave [BRD60]<BR>BF nIntegerChave [CIP]<BR>BF jdDataChave [UPMJ]<BR>BF nNumCampo [CIP]<BR>BF mnMathNumericCampo [CNTF]<BR>BF cCharCampo [EV01]<BR>BF szStringCampo [BRD60]<BR>BF nIntegerCampo [CIP]<BR>BF jdDataCampo [UPMJ]<BR>BF szDataItemCampo [DTAI]<BR>BF szNomeCampo [AA11]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PegaNodoNumCampos]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREER - Retorno Numero de Campos de Um Nodo                         </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF szStringChave [BRD60]<BR>BF nIntegerChave [CIP]<BR>BF jdDataChave [UPMJ]<BR>BF mnNumCampos [CNTF]<BR>BF nNumCampos [CIP]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [PesquisaArvore]</div><div class='er'><div class='dstrmembers'><B>Data Structure: D57TREEF - Pesquisa Nodo da Arvore                                     </B><BR>BF idArvore [GENLNG]<BR>BF cCodigoErro [EV01]<BR>BF szDescricaoErro [BRD60]<BR>BF szDataItemChave [DTAI]<BR>BF mnMathNumericChave [CNTF]<BR>BF cCharChave [EV01]<BR>BF szStringChave [BRD60]<BR>BF nIntegerChave [CIP]<BR>BF jdDataChave [UPMJ]<BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [SetaCamposFilho]</div><div class='er'><div class='dstrmembers'><B>Data Structure: INVALID <BR></div></div></div><div class='section'>EVENTS<div class='objectheader'>C Function: Implementação de Arvore - [SetaCamposPai]</div><div class='er'><div class='dstrmembers'><B>Data Structure: INVALID <BR></div></div></div></body></html>